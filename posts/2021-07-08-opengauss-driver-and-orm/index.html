<!doctype html><html lang=cn-zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>使用SQLAlchemy以多IP方式连接openGauss数据库</title><meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1>使用SQLAlchemy以多IP方式连接openGauss数据库</h1><b><time>2021.07.08 23:38</time></b>
<a href=/%20/tags/sqlalchemy>SQLAlchemy</a>
<a href=/%20/tags/python>Python</a>
<a href=/%20/tags/opengauss>openGauss</a><div><h3 id=前置声明>前置声明</h3><blockquote><p>由于 <a href=https://opengauss.org/zh/>openGauss</a> 数据库本身也开源不久，所以周边基础设施也正处于遍地开花的阶段，所以本文不保证长期的时效性，仅针对现阶段的问题，提出一种解决方案。</p></blockquote><h2 id=opengauss-介绍>openGauss 介绍</h2><p>按照官网的介绍，openGauss 是一款高性能，高安全，高可靠的开源关系型数据库管理系统，采用木兰宽松许可证v2发行。openGauss内核早期源自开源数据库PostgreSQL，融合了华为在数据库领域多年的内核经验，在架构、事务、存储引擎、优化器及ARM架构上进行了适配与优化。</p><p>openGauss 在2020年6月30日开放源代码，代码托管在 gitee 上。</p><p>目前我所在公司也主要是做数据库方面的事情，且也基于 openGauss 内核研发了一款商业版的数据库 <a href=https://enmotech.com/products/MogDB>MogDB</a>，感兴趣的也可以去了解一下。</p><h2 id=背景>背景</h2><p>针对 openGauss 的基础设施不完善，我之前基于 <a href=https://github.com/python-postgres/fe>py-postgresql</a> 1.3.0 版本，开发了 openGauss 的 python 驱动，并提交到了 openGauss 官方仓库：https://gitee.com/opengauss/openGauss-connector-python-pyog</p><p>该驱动适用于不使用 ORM，以SQL形式交互的 python 程序。</p><p>但是在对接客户的过程中，客户提出了这样的需求：</p><ul><li>程序中用到了 SQLAlchemy 做为ORM来和数据库交互</li><li>连接数据库时，需要支持类似 JDBC 多 IP 的方式连接（例如：<code>user:password@host1:port1,host2:port2/db</code> 这种形式），这种需求主要是用于后端数据库部署形态为主备架构，且没有固定的虚拟IP用于连接，所以需要将主备所有机器的IP都传递进去，但只能返回主库的连接。</li></ul><p>赶紧去扫了一下 SQLAlchemy 的源码，SQLAlchemy 中目前支持的 pg 驱动有：</p><ul><li><a href=https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2>psycopg2</a></li><li><a href=https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.pg8000>pg8000</a></li><li><a href=https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.asyncpg>asyncpg</a></li><li><a href=https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi>psycopg2cffi</a></li><li><a href=https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.pypostgresql>py-postgresql</a></li><li><a href=https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.pygresql>pygresql</a></li></ul><p>其实只要在驱动里面实现了 <a href=https://www.python.org/dev/peps/pep-0249/>PEP-249</a> (DBAPI 2.0 接口规范) 就可以。但是我们都知道，在使用 SQLAlchemy 创建 engine 的时候，需要在 <code>://</code> 前面使用固定的字符串进行驱动的选择。比如 <code>postgresql+pypostgresql://...</code>，内部其实就是把加号 replace 成点，然后去加载对应的驱动模块文件。</p><p>但是 openGauss 的驱动可能是目前不支持的，所以我们需要解决的就是两个问题：</p><ul><li>开发一个驱动，能够实现 DBAPI 2.0 接口规范，且支持多IP连接</li><li>增强 SQLAlchemy ，支持我们开发的 openGauss 驱动</li></ul><p>解决了以上两个问题后，就可以和平时使用 SQLAlchemy 一样来操作 openGauss 了。</p><h3 id=完整架构图>完整架构图</h3><p><figure><img src=https://static.vimiix.com/upic/2021-07-08/WeChat665cbcb9d30440234880c049693b01ed.png alt></figure></p><h2 id=py-opengauss-库>py-opengauss 库</h2><p>第一个问题就是要开发一个 openGauss 的驱动，我们上面提到我之前基于 <a href=https://github.com/python-postgres/fe>py-postgresql</a> 1.3.0 开发了一个驱动，但是当时仅支持了 openGauss 的连接和SQL交互，现在需要基于目前的需求进行开发。</p><blockquote><p>代码目前已经发布到 github 上，源码地址：https://github.com/vimiix/py-opengauss</p><p>包已经推送到 pypi 上，最新版本 1.3.6</p></blockquote><p>首先是 DBAPI 2.0 接口，庆幸的是 py-postgresql 本身就已经支持了 DBAPI 2.0 接口规范，代码位于 <code>postgresql.driver.dbapi20</code>。</p><p>所以我们需要做的是如何在接口上支持多IP。</p><p>为了减少对于现有代码的侵入，我修改了 dbapi20 模块中 <a href=https://github.com/vimiix/py-opengauss/blob/6cb1b6ba46a9ad86f091f5b397454dac82ed622e/py_opengauss/driver/dbapi20.py#L416><code>connect</code></a> 函数，上层需要通过 <code>host</code> 字段将IP部分（包含所有主机和端口号），传递进来进行处理。</p><p>例如： <code>{'host': 'host1:5432,host2:6432'}</code></p><p>在 connect 函数中，会遍历去进行连接，直到找到主库的连接后停止遍历返回连接。</p><p>这样就解决了第一个问题。</p><p>这部分功能已经发布到 1.3.6 版本中，所以在 pip 安装的时候需指定版本：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>pip install py-opengauss<span style=color:#f92672>==</span>1.3.6
</code></pre></div><h2 id=sqlalchemy-定制>SQLAlchemy 定制</h2><p>接下来是第二个问题，需要增强 SQLAlchemy 支持 py-opengauss 驱动。</p><blockquote><p>定制后的代码地址：https://github.com/vimiix/sqlalchemy</p></blockquote><p>我 fork 了一份 SQLAlchemy 的代码，在现有的代码上，在 <code>lib/sqlalchemy/dialects/postgresql</code> 中新增 pyopengauss 的模块，在内部 dbapi 接口处返回我们的驱动即可：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@classmethod</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dbapi</span>(cls):
  <span style=color:#f92672>from</span> py_opengauss.driver <span style=color:#f92672>import</span> dbapi20
  <span style=color:#66d9ef>return</span> dbapi20
</code></pre></div><p>这样我们就在可以 create_engine 的时候，使用 <code>postgresql+pyopengauss://</code> 这个前缀来进行连接了。</p><p>此时还存在另外一个问题，我们在业务层创建 engine 时传入的连接字符串假如是多IP形式的，SQLAlchemy 内部会通过一个固定的<a href=https://github.com/sqlalchemy/sqlalchemy/blob/990069b2e8627b7c7c649d1198390ec728b43089/lib/sqlalchemy/engine/url.py#L700>正则表达式</a>来匹配 <code>user</code>, <code>password</code>, <code>host</code>, <code>port</code>,<code>db</code> 以及 <code>query</code> 。但是对于多IP的字符串，匹配出来以后仅会匹配到第一个 <code>host</code> 部分，剩余部分被匹配到了 <code>port</code> 部分，类似下面这样：</p><p><figure><img src=https://static.vimiix.com/upic/2021-07-08/WeChat8b3e7a354445dda961402c8102d1a308.png alt></figure></p><p>这样的话，对于 port 字段进行 <code>int(port)</code> 转换整型的时候，必然会报错。</p><p>所以我对于正则表达式进行了<a href=https://github.com/vimiix/sqlalchemy/blob/49b7c05cd4c65e7d9967b8664aadae38cd2e9acb/lib/sqlalchemy/engine/url.py#L700>修改</a>，让 <code>host:port</code> 部分先不拆开，一起匹配出来， 然后我们手动进行解析。如果是多IP的情况，就不进行拆分，直接放入 <code>host</code> 字段传递给驱动（上面提到过，驱动部分我们也是通过该字段解析的）。如果不是多IP形式，就直接 split 拆分，<code>host</code> 字段放 host， <code>port</code> 字段放 port ，和常规连接一样提交给驱动即可。</p><p>具体代码实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>ipv4host <span style=color:#f92672>=</span> components<span style=color:#f92672>.</span>pop(<span style=color:#e6db74>&#34;ipv4host&#34;</span>)
        ipv6host <span style=color:#f92672>=</span> components<span style=color:#f92672>.</span>pop(<span style=color:#e6db74>&#34;ipv6host&#34;</span>)
        <span style=color:#66d9ef>if</span> ipv4host:
            <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;,&#39;</span> <span style=color:#f92672>in</span> ipv4host:
                <span style=color:#75715e># multiple host</span>
                components[<span style=color:#e6db74>&#34;host&#34;</span>] <span style=color:#f92672>=</span> ipv4host
            <span style=color:#66d9ef>elif</span> <span style=color:#e6db74>&#39;:&#39;</span> <span style=color:#f92672>in</span> ipv4host:
                host, port <span style=color:#f92672>=</span> ipv4host<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;:&#39;</span>, <span style=color:#ae81ff>1</span>)
                components[<span style=color:#e6db74>&#34;host&#34;</span>] <span style=color:#f92672>=</span> host
                components[<span style=color:#e6db74>&#34;port&#34;</span>] <span style=color:#f92672>=</span> int(port)
            <span style=color:#66d9ef>else</span>:
                components[<span style=color:#e6db74>&#34;host&#34;</span>] <span style=color:#f92672>=</span> ipv4host
        <span style=color:#66d9ef>else</span>:
            components[<span style=color:#e6db74>&#34;host&#34;</span>] <span style=color:#f92672>=</span> ipv6host
</code></pre></div><p>进行了多IP的适配以后，此时的 SQLAlchemy 就能够满足我们的需求了。</p><p>由于我们是基于 SQLAlchemy 的定制，且为了业务代码的少变更，所以安装方式只能是通过下载源码，然后手动通过 <code>python setup.py install</code> 来进行安装。安装后，业务层仅需要修改一个连接字符串即可。</p><h2 id=使用方式>使用方式</h2><ol><li>安装 py-opengauss</li></ol><ul><li>通过 pip 安装</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>pip install py-opengauss<span style=color:#f92672>==</span>1.3.6
</code></pre></div><ul><li>通过源码安装</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/vimiix/py-opengauss.git
cd py-opengauss
python3 setup.py install
</code></pre></div><ol start=2><li>安装定制后的 SQLAlchemy</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/vimiix/sqlalchemy
cd sqlalchemy
python3 setup.py install
</code></pre></div><ol start=3><li>业务层修改连接串</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> sqlalchemy <span style=color:#f92672>import</span> create_engine
engine <span style=color:#f92672>=</span> create_engine(<span style=color:#e6db74>&#39;postgresql+pyopengauss://user:password@host1:port1,host2:port2/db&#39;</span>)
</code></pre></div></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/2021-12-21-learn-distributed-transaction/>分布式事务笔记(XA,TCC,Saga)</a></li><li><a href=/posts/2021-09-01-simulate-disk-readonly-scenario/>磁盘只读（readonly）故障场景模拟</a></li><li><a href=/posts/2021-07-08-opengauss-driver-and-orm/>使用SQLAlchemy以多IP方式连接openGauss数据库</a></li><li><a href=/posts/2021-04-07-concurrency-in-go/>Golang的并行模式实践</a></li><li><a href=/posts/2021-03-22-auth-windows-user-in-golang/>Golang实现Windows系统用户和密码校验</a></li></ul></div></div></aside><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://www.vimiix.com/posts/2021-07-08-opengauss-driver-and-orm/",this.page.identifier="/posts/2021-07-08-opengauss-driver-and-orm/"};(function(){var a=document,b=a.createElement('script');b.src='https://vimiix-blog.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2021
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>