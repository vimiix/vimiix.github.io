<!doctype html><html lang=cn-zh><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Git开发记录-合并多条commit最佳实践</title>
<meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/vimiix-blog/css/style.css></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=http://vimiix.com/vimiix-blog/><b>首页</b></a>.
<a href=/vimiix-blog/posts/><b>文章列表</b></a>.
<a href=/vimiix-blog/categories/><b>分类</b></a>.
<a href=/vimiix-blog/tags/><b>标签</b></a>.
<a href=/vimiix-blog/friends/><b>友链</b></a>.
<a href=/vimiix-blog/about/><b>关于</b></a>.
<a href=/vimiix-blog/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1>Git开发记录-合并多条commit最佳实践</h1><b><time>2018.08.13 19:22</time></b>
<a href=/vimiix-blog/%20/tags/git>git</a><div><h2 id=问题>问题</h2><p>常规的多人基于 GIT 协作开发的时候，都是遵循先 fork 一份主版本代码到自己的账号下面，然后基于本账户的版本，开分支来开发功能或修 Bug，完成以后再讲修改的内容，提交一个完整的 PR 贡献回主版本。</p><p>在本分支上开发的过程中，有时候不得不先提交到自己账号下面的克隆版本中来测试（比如豆瓣的<code>dae pre</code>，无法在本地生成预览，需要提交到远端），我们不能保证一次性提交就做到完美，避免不了会往复的修改后提交，这样的一次次测试用的 commit 属于是冗余的琐碎信息，对于主版本迭代是没有价值的。如果直接在基于该分支提交 PR，甚至被<code>merge</code>到<code>upstream/master</code>主版本中，这些不必要的 commit 信息也会包含进主版本中。这当然不是一个理想的迭代方式。</p><p>现在问题明确以后，就是一个目标：<strong>将这些开发中的所有 commit 都合并为一条有意义的 commit 信息提交给主版本</strong>。</p><h2 id=解决方案>解决方案</h2><p>为了实现这一目标，有两种方式，根据情况来选择：</p><h3 id=git-rebase--i-headn>git rebase -i HEAD~n</h3><p><code>git log</code>查看当前分支，假设现在有三条 commit 记录，如下：</p><p><figure><img src=http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/image-20180813185617977.png alt=image-20180813185617977></figure></p><p>想合并最近这两天记录为一条，可以这样做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase -i HEAD~3
</span></span></code></pre></div><p><code>HEAD</code> 就是 git 当前的版本指针，不懂的自行查阅。</p><p><code>3</code> 代表要合并之前的几条记录</p><p>这时会出现下面这个编辑界面，你需要选择<code>pick</code>（选择）第一条来作为合并后提交的 commit 信息.</p><p><figure><img src=http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/image-20180813185814408.png alt=image-20180813185149617></figure></p><p>将要合并的条目前面的<code>pick</code>修改为 <code>s</code>或者 <code>squash</code>，都可以一个是缩写一个是全称（压缩的意思）git 只能将 log 向前压缩合并，所以选择最早的一条记录作为合并后的提交信息。</p><p><figure><img src=http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/image-20180813185847494.png alt=image-20180813185847494></figure></p><p><code>:wq</code>保存退出，终端会出现类似这样的分支：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git:<span style=color:#f92672>(</span>0184399<span style=color:#f92672>)</span> ✗
</span></span></code></pre></div><p><code>0184399</code> 这个是合并过程中的一个临时版本号，因为压缩是需要一条一条来合并的，这其中遇到冲突的话，需要手动处理以后才能合并。</p><p>如果没有冲突的话，执行下面的指令继续合并：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase --continue
</span></span></code></pre></div><p>直到合并结束，终端的分支名会再次出现你自己创建的分支名就成功了。</p><p>如果过程中任何时候想放弃合并，执行下面的指令即可结束本次合并操作流程:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase --abort
</span></span></code></pre></div><p>执行成功以后，再次<code>git log</code>查看，出现下面这样，就表示合并成功了，三条记录合并到一条了：</p><p><figure><img src=http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/image-20180813190354456.png alt=image-20180813190354456></figure></p><p>这时候，就可以推送到远端了，因为之前测试远端有我们提交的 commit 信息，此时和本地已经不一致了（因为我们的上述操作），所以简单的<code>git push</code>上去了，会被远端拒绝，这时候就需要霸道一点，使用<code>--force</code>参数强行覆盖远端的版本，就可以了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push --force
</span></span></code></pre></div><p>这种方案的好处是，也许我们之前就已经在主版本中提交了 PR，后面有添加了修改，合并后，PR 会自动更新 commit 信息，不需要重新开 PR，就可以 merge。但是比较繁琐的是需要一步一步手动处理自己在每次 commit 中的冲突</p><h3 id=git-checkout--b>git checkout -b</h3><p>第二种方案比较简单，采用<strong>开发-发布</strong>分离的思想。开发使用一个分支，提交 PR 发布的时候，直接新开一个分支，将开发分支的更新后的代码 merge 过来即可。无需关心开发过程中经历了怎么样的“磨难”，只关心结果。</p><p>具体操作流程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 切换到主分支</span>
</span></span><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 从上游主版本更新代码到最新</span>
</span></span><span style=display:flex><span>$ git pull upstream master
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 新建一个发布分支</span>
</span></span><span style=display:flex><span>$ git checkout -b release_branch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用带 `no-commit&amp;squash` 参数的方式将开发分支的代码合并过来</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这仿佛就好像你在开发分支上一次性完美地写完了所有代码</span>
</span></span><span style=display:flex><span>$ git merge origin/working_branch --no-commit --squash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 添加commit 信息提交 OK</span>
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#34;the work is done and ready for release&#34;</span>
</span></span></code></pre></div><p>是不是很帅气呢？反正我觉得是~~</p><p>可是如果提交了 PR 以后，code review 没通过，这时候，又进行了多次的修改以后，就需要关闭本次 PR，重新这样操作以后开辟新的 PR 来提交。如果 code review 过程中，可能有有价值的讨论信息在 PR 中，就需要使用第一种方案，来合并了。</p><p>—— EOF ——</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/vimiix-blog/posts/2023-06-21-manage-go-multiple-versions/>Shell 函数实现Go语言多版本管理轻量级方案</a></li><li><a href=/vimiix-blog/posts/2021-12-21-learn-distributed-transaction/>分布式事务笔记(XA,TCC,Saga)</a></li><li><a href=/vimiix-blog/posts/2021-09-01-simulate-disk-readonly-scenario/>磁盘只读（readonly）故障场景模拟</a></li><li><a href=/vimiix-blog/posts/2021-07-08-opengauss-driver-and-orm/>使用SQLAlchemy以多IP方式连接openGauss数据库</a></li><li><a href=/vimiix-blog/posts/2021-04-07-concurrency-in-go/>Golang的并行模式实践</a></li></ul></div></div></aside><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="http://vimiix.com/vimiix-blog/posts/2018-08-13-git-best-practice/",this.page.identifier="/vimiix-blog/posts/2018-08-13-git-best-practice/"};(function(){var e=document,t=e.createElement("script");t.src="https://vimiix-blog.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2023
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>