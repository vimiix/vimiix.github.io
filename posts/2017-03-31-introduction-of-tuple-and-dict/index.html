<!doctype html><html lang=cn-zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Python|对于元组和字典的认识</title><meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1>Python|对于元组和字典的认识</h1><b><time>2017.03.31 15:00</time></b>
<a href=/%20/tags/tuple>tuple</a>
<a href=/%20/tags/dict>dict</a>
<a href=/%20/tags/python>Python</a><div><p>本篇是一篇随手笔记，记录了对于 Python 的数据类型中元组（Tuple）和字典（Dict）的一些认识，以及部分内置方法的介绍。</p><h2 id=元组-tuple>元组 Tuple</h2><h5 id=特点元组内的数据不可变>特点：元组内的数据不可变</h5><h5 id=一个元素的定义t--1>一个元素的定义：T = （1，）</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> T<span style=color:#f92672>=</span>(<span style=color:#ae81ff>1</span>,)
	<span style=color:#f92672>&gt;&gt;&gt;</span> type(T)
	<span style=color:#f92672>&lt;</span>type <span style=color:#e6db74>&#39;tuple&#39;</span><span style=color:#f92672>&gt;</span>
</code></pre></div><h5 id=特殊的元组可变的元组>特殊的元组：&ldquo;可变"的元组</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> T<span style=color:#f92672>=</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>])
	<span style=color:#f92672>&gt;&gt;&gt;</span> T[<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;vimiix&#39;</span>
	<span style=color:#f92672>&gt;&gt;&gt;</span> T
	(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;vimiix&#39;</span>])
</code></pre></div><p>看上去元组发生了变化，但真正变化的是[1，2，3]这个列表内的元素发生了变化，但是这个列表在 T 这个元组中的内存地址是没有改变的。</p><p>结论：实际是元组的元素包含了可变的元素，但是元组中元素的内存地址没有变，所以所谓的元组不可变是指元素指向的内存地址是不变</p><h2 id=字典-dict>字典 Dict</h2><h5 id=特点>特点：</h5><h5 id=1字典是-python-中唯一的映射类型>1、字典是 Python 中唯一的映射类型</h5><h5 id=2字典的键key必须是不可变的对象---因为字典在计算机中是通过-hash-算法存储的hash-的特点是由-key-来计算存储的如果-key-可变将会导致数据混乱>2、字典的键（KEY）必须是不可变的对象&mdash;>因为字典在计算机中是通过 Hash 算法存储的，Hash 的特点是由 KEY 来计算存储的，如果 KEY 可变，将会导致数据混乱。</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> D <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>,<span style=color:#e6db74>&#39;vimiix&#39;</span>:<span style=color:#ae81ff>88</span>}
	<span style=color:#f92672>&gt;&gt;&gt;</span> type(D)
	<span style=color:#f92672>&lt;</span>type <span style=color:#e6db74>&#39;dict&#39;</span><span style=color:#f92672>&gt;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> D<span style=color:#f92672>=</span>{[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]:<span style=color:#ae81ff>100</span>}
	Traceback (most recent call last):
	  File <span style=color:#e6db74>&#34;&lt;pyshell#15&gt;&#34;</span>, line <span style=color:#ae81ff>1</span>, <span style=color:#f92672>in</span> <span style=color:#f92672>&lt;</span>module<span style=color:#f92672>&gt;</span>
	    D<span style=color:#f92672>=</span>{[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]:<span style=color:#ae81ff>100</span>}
	<span style=color:#a6e22e>TypeError</span>: unhashable type: <span style=color:#e6db74>&#39;list&#39;</span> (<span style=color:#960050;background-color:#1e0010>这里提示</span>list是不能被Hash计算的数据类型<span style=color:#960050;background-color:#1e0010>，因为</span>list是可变的数据类型)
	<span style=color:#f92672>&gt;&gt;&gt;</span>
</code></pre></div><p>由此错误可以看出，字典的键只能使用不可变的对象（元组是可以的），但是对于字典的值没有此要求
键值对用冒号‘：’分割，每个对之间用逗号‘，’分开，所有这些用花括号‘{}’包含起来
字典中的键值对是没有顺序的，故不可以用索引访问，只可以通过键取得所对应的值</p><h5 id=拓展如果定义的过程中出现相同的键最后存储的时候回保留最后的一个键值对>拓展：如果定义的过程中，出现相同的键，最后存储的时候回保留最后的一个键值对）</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> D<span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>}
	<span style=color:#f92672>&gt;&gt;&gt;</span> D
	{<span style=color:#ae81ff>1</span>: <span style=color:#ae81ff>3</span>}
</code></pre></div><h3 id=创建与访问>创建与访问</h3><p>第一种创建方式：直接通过花括号包含键值对来创建</p><p>第二种创建方式：利用内置函数 dict()来创建，注意！dict（）括号内只能有一个参数，要把所有的键值对括起来</p><p>（1）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> D <span style=color:#f92672>=</span>dict((<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>),(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>),(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>))
	Traceback (most recent call last):
	  File <span style=color:#e6db74>&#34;&lt;pyshell#20&gt;&#34;</span>, line <span style=color:#ae81ff>1</span>, <span style=color:#f92672>in</span> <span style=color:#f92672>&lt;</span>module<span style=color:#f92672>&gt;</span>
	    D <span style=color:#f92672>=</span>dict((<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>),(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>),(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>))
	<span style=color:#a6e22e>TypeError</span>: dict expected at most <span style=color:#ae81ff>1</span> arguments, got <span style=color:#ae81ff>3</span>
	<span style=color:#f92672>&gt;&gt;&gt;</span> D <span style=color:#f92672>=</span>dict(((<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>),(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>),(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>)))
	<span style=color:#f92672>&gt;&gt;&gt;</span> D
	{<span style=color:#ae81ff>1</span>: <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>: <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>: <span style=color:#ae81ff>6</span>}
</code></pre></div><p>（2）还可以指定关键字参数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> D<span style=color:#f92672>=</span>dict(vimiix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;VIMIIX&#39;</span>)
	<span style=color:#f92672>&gt;&gt;&gt;</span> D
	{<span style=color:#e6db74>&#39;vimiix&#39;</span>: <span style=color:#e6db74>&#39;VIMIIX&#39;</span>}
</code></pre></div><p>这里的小写‘vimiix’不可以加单引号，加了会报错！</p><p>（3）dict 的内置方法 .fromkeys 有两个参数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> D <span style=color:#f92672>=</span> dict<span style=color:#f92672>.</span>fromkeys((<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#39;vimiix&#39;</span>),(<span style=color:#e6db74>&#39;common&#39;</span>,<span style=color:#e6db74>&#39;value&#39;</span>))
	<span style=color:#f92672>&gt;&gt;&gt;</span> D
	{<span style=color:#ae81ff>1</span>: (<span style=color:#e6db74>&#39;common&#39;</span>, <span style=color:#e6db74>&#39;value&#39;</span>), <span style=color:#e6db74>&#39;vimiix&#39;</span>: (<span style=color:#e6db74>&#39;common&#39;</span>, <span style=color:#e6db74>&#39;value&#39;</span>)}
	<span style=color:#f92672>&gt;&gt;&gt;</span>
</code></pre></div><p>实际的生产过程中，都是使用字典生成式来创建，根据现有的数据来生成对应的数据，有数据才有意义。</p><p>字典生成式栗子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> L1 <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]
	<span style=color:#f92672>&gt;&gt;&gt;</span> L2 <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;a&#39;</span>,<span style=color:#e6db74>&#39;v&#39;</span>,<span style=color:#e6db74>&#39;vimiix&#39;</span>]
	<span style=color:#f92672>&gt;&gt;&gt;</span> D<span style=color:#f92672>=</span>{a:b <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> L1 <span style=color:#66d9ef>for</span> b <span style=color:#f92672>in</span> L2}
	<span style=color:#f92672>&gt;&gt;&gt;</span> D
	{<span style=color:#ae81ff>1</span>: <span style=color:#e6db74>&#39;vimiix&#39;</span>, <span style=color:#ae81ff>2</span>: <span style=color:#e6db74>&#39;vimiix&#39;</span>, <span style=color:#ae81ff>3</span>: <span style=color:#e6db74>&#39;vimiix&#39;</span>}
</code></pre></div><h6 id=此处只是一个生成式的栗子但并不是理想答案待学习如何生成一一对应的键值对>[???]此处只是一个生成式的栗子，但并不是理想答案，待学习如何生成一一对应的键值对</h6><h3 id=字典的内置方法>字典的内置方法：</h3><h5 id=font-colorbluegetfont>get():</h5><p>获取键所对应的值，如果未找到返回 None，找到返回对应的值</p><h5 id=font-colorbluepopkeyfont>pop(key):</h5><p>弹出 key 对应的值，默认最后一个</p><h5 id=font-colorbluepopitemfont>popitem():</h5><p>随机返回并删除字典中的一对键和值（项）。为什么是随机删除呢？因为字典是无序的，没有所谓的“最后一项”或是其它顺序。在工作时如果遇到需要逐一删除项的工作，用 popitem()方法效率很高。</p><h5 id=font-colorblueupdatefont>update():</h5><p>更新或者新增一个键值对（有则改之无则加勉）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python>	<span style=color:#f92672>&gt;&gt;&gt;</span> D<span style=color:#f92672>.</span>update({<span style=color:#e6db74>&#39;newitem&#39;</span>:<span style=color:#e6db74>&#39;update&#39;</span>})
	<span style=color:#f92672>&gt;&gt;&gt;</span> D
	{<span style=color:#e6db74>&#39;newitem&#39;</span>: <span style=color:#e6db74>&#39;update&#39;</span>, <span style=color:#ae81ff>1</span>: <span style=color:#e6db74>&#39;vimiix&#39;</span>, <span style=color:#ae81ff>2</span>: <span style=color:#e6db74>&#39;vimiix&#39;</span>, <span style=color:#ae81ff>3</span>: <span style=color:#e6db74>&#39;vimiix&#39;</span>}
</code></pre></div></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/2021-07-08-opengauss-driver-and-orm/>使用SQLAlchemy以多IP方式连接openGauss数据库</a></li><li><a href=/posts/2021-04-07-concurrency-in-go/>Golang的并行模式实践</a></li><li><a href=/posts/2021-03-22-auth-windows-user-in-golang/>Golang实现Windows系统用户和密码校验</a></li><li><a href=/posts/2020-03-11-beanstalkd-note/>beanstalkd消息队列</a></li><li><a href=/posts/2020-02-21-richardson-model/>[译]Richardson成熟度模型</a></li></ul></div></div></aside><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://www.vimiix.com/posts/2017-03-31-introduction-of-tuple-and-dict/",this.page.identifier="/posts/2017-03-31-introduction-of-tuple-and-dict/"};(function(){var a=document,b=a.createElement('script');b.src='https://vimiix-blog.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2021
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>