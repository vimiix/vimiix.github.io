<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hi, I'm Vimiix</title><link>http://www.vimiix.com/vimiix-blog/posts/</link><description>Recent content in Posts on Hi, I'm Vimiix</description><generator>Hugo -- gohugo.io</generator><language>cn-zh</language><copyright>Copyright (c) 2017-2021, Vimiix Yao; All rights reserved</copyright><lastBuildDate>Fri, 15 Dec 2023 00:50:48 +0000</lastBuildDate><atom:link href="http://www.vimiix.com/vimiix-blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>SSX，一个有记忆的 ssh 客户端</title><link>http://www.vimiix.com/vimiix-blog/posts/2023-12-15-ssx/</link><pubDate>Fri, 15 Dec 2023 00:50:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2023-12-15-ssx/</guid><description>需求来源 对于一个后端程序员来说，在工作中免不了要和繁杂的服务器打交道，ssh 是不可或缺的开发工具。但每次登录都需要输入密码的行为，对于认为一切皆可自动化的程序员来说，肯定是有点繁琐的（如果您是使用图形化界面的用户可忽略）。
所以我在前段时间考虑，我应该自己实现一个 ssh 客户端，它不需要拥有许多复杂的功能，只需要满足我以下这几个需求即可满足日常使用：
和 ssh 保持差不多的使用习惯 仅在第一次登录时询问我密码，后续使用无需再提供密码 可以给服务器它任意的标签，这样我就可以自由地通过IP 或者标签来登录 于是乎，近期我在业余时间就设计并编写了 ssx 这个轻量级的具有记忆的 ssh 客户端。它完美的实现了上面我所需要的功能，也已经被我愉快的应用到了日常的开发中。
使用方式 下面就简单介绍一下 ssx 的使用方式。
ssx 是通过 golang 开发的一个独立的二进制文件，安装方式就是从 release 页面下载对应平台的软件包，解压后把 ssx 二进制放到系统的任意目录下，这里我习惯放到 /usr/local/bin 目录下，如果你选择其他目录下，需要确保存放的目录添加到 $PATH 环境变量中，这样后续使用我们就不用再添加路径前缀，直接通过 ssx 命令就可以运行了。
登录服务器 使用 ssx 登录服务器的时候，基本和 ssh 使用习惯一致，下面是基本命令模式：
ssx [-s] [USER@]HOST[:PORT] [-k IDENTITY_FILE] 在这个命令中，USER 是可以省略的，如果省略则是系统当前用户名；PORT 是可以省略的，默认是 22，-k IDENTITY_FILE 代表如果是使用私钥登录，则通过 -k 来指定私钥的路径，也是可以省略的，默认是 ~/.ssh/id_rsa，当然了，前提是这个文件存在。所以最精简的登录命令就是：ssx &amp;lt;ip&amp;gt;
当首次登录，不存在可用私钥时，会通过交互方式来让用户输入密码，一旦登录成功，这个密码就会被 ssx 保存到本地的数据文件中 (默认为 ~/.ssx/db， 可通过环境变量 SSX_DB_PATH 进行自定义)，下次登录时，仍然执行 ssx &amp;lt;ip&amp;gt; 即可自动登录。
注意，登录过的服务器，再次登录时，我嫌输入全部 IP 比较麻烦，所以 ssx 支持输入 IP 中的部分字符，自动搜索匹配进行登录。</description></item><item><title>Shell 函数实现Go语言多版本管理轻量级方案</title><link>http://www.vimiix.com/vimiix-blog/posts/2023-06-21-manage-go-multiple-versions/</link><pubDate>Wed, 21 Jun 2023 14:50:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2023-06-21-manage-go-multiple-versions/</guid><description>现有的工具方案 gvm: https://github.com/moovweb/gvm g: https://github.com/voidint/g 我的方案 优点：
原生：基于 go 语言本身支持多版本的能力实现，可以下载任何官方发布的版本 简单：shell 函数实现，直接集成到 bashrc 或 zshrc 中即可使用，无需额外配置 可定制化：代码简单可根据自身需求定制 代码实现 gist地址：https://gist.github.com/vimiix/0927fdfbea926e869a2c631db9eeae8b
####### GOLANG VERSION MANAGE FUNCTIONS ###### # ref: https://go.dev/doc/manage-install function goinstall() { echo &amp;#34;Downloading go$1 ...&amp;#34; go install golang.org/dl/go$1@latest &amp;amp;&amp;amp; go$1 download } function gouse() { gopath=$(go env GOPATH) if test -x ${gopath}/bin/go$1; then rm -f ${gopath}/bin/go echo &amp;#34;Relink go with go$1 ...&amp;#34; ln -s ${gopath}/bin/go$1 ${gopath}/bin/go echo &amp;#34;Done&amp;#34; else echo &amp;#34;Version $1 not installed&amp;#34; fi } function golist() { current=$(go version | awk &amp;#39;{print $3}&amp;#39; | cut -c3-) for v in $(ls $(go env GOPATH)/bin | grep -E &amp;#39;go(\d.</description></item><item><title>分布式事务笔记(XA,TCC,Saga)</title><link>http://www.vimiix.com/vimiix-blog/posts/2021-12-21-learn-distributed-transaction/</link><pubDate>Tue, 21 Dec 2021 20:25:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2021-12-21-learn-distributed-transaction/</guid><description>基础理论 CAP理论 一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。这被称为CAP理论，已经被证实。
一致性（Consistency） ：在分布式系统中所有的数据备份，在同一时刻都保持一致状态，如无法保证状态一致，直接返回错误。 可用性（Availability）：在集群中一部分节点故障，也能保证客户端访问系统并得到正确响应，允许一定时间内数据状态不一致。 分区容错性（Partition tolerance）：分布式系统在遇到任何网络分区故障时，仍然能保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生故障。 ACID特性（刚性事务，强一致性） 把多条语句作为一个整体进行操作的功能，称为数据库事务。数据库事务可以确保该事务范围内的所有操作全部成功或者全部失败。
事务具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。
原子性（Atomicity）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 事务隔离（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 BASE理论（柔性事务） BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）
基本可用（Basically Available）：是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。 软状态（Soft state）：和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 最终一致性（Eventually consistent）：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。
分布式方案 XA规范 Open Group组织定义的一套DTP（Distributed Transaction Processing）分布式事务处理模型，主要包含以下四部分：
AP（应用程序） TM（事务管理器）：中间件，负责多个事物之间的协调 RM（资源管理器）：数据库等资源 CRM（通信资源管理器）：消息中间件 XA规范包括两套函数，分别以 xa_ 和 ax_ 开头，使 TM 可以对 RM 进行的操作：
xa_open,xa_close：建立和关闭与资源管理器的连接； xa_start,xa_end：开始和结束一个本地事务； xa_prepare,xa_commit,xa_rollback：预提交、提交、回滚一个本地事务； xa_recover：回滚一个已进行预提交的事务； ax_开头的函数使资源管理器可以动态地在事务管理器中进行注册，并可以对XID(TRANSACTION IDS)进行操作； ax_reg,ax_unreg；允许一个资源管理器在一个TMS(TRANSACTION MANAGER SERVER)中动态注册或撤消注册。 基于XA规范衍生出下面的两阶段提交（2PC）、三阶段提交（3PC）。
2PC（两阶段提交） 2PC就是分布式事务中将事务分为两步进行提交，两阶段提交基于ACID理论。
提交流程：
准备阶段：预提交，首先两个事务都会去操作自己的数据库，但是这次操作数据库并不会commit，也就是说不生效，只是试探性的看看这次操作能否成功，无论成功与否，如果成功的话将会记录此次的操作记录，并一直锁定要操作的数据资源，返回结果给事务管理器，如果失败则直接回滚所做的操作，并立即释放锁定的数据资源，也将结果返回给事务管理器； 提交阶段：交易中间件事务管理器收到所有的事务预操作返回结果，并审查所有数据库返回的预提交结果，如所有数据库都可以提交，交易中间件将要求所有数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚其操作，这样该全局事务被回滚。 二阶段提交的一些问题：</description></item><item><title>磁盘只读（readonly）故障场景模拟</title><link>http://www.vimiix.com/vimiix-blog/posts/2021-09-01-simulate-disk-readonly-scenario/</link><pubDate>Wed, 01 Sep 2021 16:15:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2021-09-01-simulate-disk-readonly-scenario/</guid><description>假设服务器目前有多个盘，vdb1这块分区盘专门用于数据库程序的数据目录，我们就用 vdb1 这个盘来模拟只读故障场景。
1. 卸载指定盘 umount /dev/vdb1 想要如期卸载掉，需要确保该盘上没有被正在运行进程依赖，如果有运行中的进程依赖这个盘，会报如下报 target is busy 的错误：
umount: /opt: target is busy. 遇到该错误时，可以通过lsof [mountpoint] 命令来查看有哪些进程依赖这块盘，kill 掉相应的进程后重新卸载。
2. 配置伪设备来镜像 /dev/vdb1 的内容 卸载成功后，我们通过 losetup 指令来配置一个loop设备（在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件）。
losetup /dev/loop0 /dev/vdb1 执行指令后，可以通过 losetup -l 查看当前服务器上的 loop 设备列表：
3. 挂载 /dev/loop0 我们已经有一个 /dev/loop0 的伪设备镜像到了 /dev/vdb1 上，此时，我们来挂载 /dev/loop0 这个伪设备：
mount /dev/loop0 /opt -o rw,errors=remount-ro 通过 df -h 可以查看到 /dev/loop0 已经正常挂载上了
4. 正常启动应用进程（这里测试用opengauss数据库） gs_ctl start -D /opt/mogdb/data/ 5. 修改磁盘为只读模式（故障注入） blockdev 命令行工具是用于控制区块设备程序</description></item><item><title>使用SQLAlchemy以多IP方式连接openGauss数据库</title><link>http://www.vimiix.com/vimiix-blog/posts/2021-07-08-opengauss-driver-and-orm/</link><pubDate>Thu, 08 Jul 2021 23:38:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2021-07-08-opengauss-driver-and-orm/</guid><description>前置声明 由于 openGauss 数据库本身也开源不久，所以周边基础设施也正处于遍地开花的阶段，所以本文不保证长期的时效性，仅针对现阶段的问题，提出一种解决方案。
openGauss 介绍 按照官网的介绍，openGauss 是一款高性能，高安全，高可靠的开源关系型数据库管理系统，采用木兰宽松许可证v2发行。openGauss内核早期源自开源数据库PostgreSQL，融合了华为在数据库领域多年的内核经验，在架构、事务、存储引擎、优化器及ARM架构上进行了适配与优化。
openGauss 在2020年6月30日开放源代码，代码托管在 gitee 上。
目前我所在公司也主要是做数据库方面的事情，且也基于 openGauss 内核研发了一款商业版的数据库 MogDB，感兴趣的也可以去了解一下。
背景 针对 openGauss 的基础设施不完善，我之前基于 py-postgresql 1.3.0 版本，开发了 openGauss 的 python 驱动，并提交到了 openGauss 官方仓库：https://gitee.com/opengauss/openGauss-connector-python-pyog
该驱动适用于不使用 ORM，以SQL形式交互的 python 程序。
但是在对接客户的过程中，客户提出了这样的需求：
程序中用到了 SQLAlchemy 做为ORM来和数据库交互 连接数据库时，需要支持类似 JDBC 多 IP 的方式连接（例如：user:password@host1:port1,host2:port2/db 这种形式），这种需求主要是用于后端数据库部署形态为主备架构，且没有固定的虚拟IP用于连接，所以需要将主备所有机器的IP都传递进去，但只能返回主库的连接。 赶紧去扫了一下 SQLAlchemy 的源码，SQLAlchemy 中目前支持的 pg 驱动有：
psycopg2 pg8000 asyncpg psycopg2cffi py-postgresql pygresql 其实只要在驱动里面实现了 PEP-249 (DBAPI 2.0 接口规范) 就可以。但是我们都知道，在使用 SQLAlchemy 创建 engine 的时候，需要在 :// 前面使用固定的字符串进行驱动的选择。比如 postgresql+pypostgresql://...，内部其实就是把加号 replace 成点，然后去加载对应的驱动模块文件。</description></item><item><title>Golang的并行模式实践</title><link>http://www.vimiix.com/vimiix-blog/posts/2021-04-07-concurrency-in-go/</link><pubDate>Wed, 07 Apr 2021 18:15:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2021-04-07-concurrency-in-go/</guid><description>Goroutine C#、Lua、Python 的用户可能会发现 Go 的 goroutine 和协程之间有很多相似之处，没错，从命名上也可以看出二者具有相似性。
但二者之间也有些区别：
goroutine 隐含了并行的特性，一切交给 go 的 runtime 来实现调度，而协程需要应用自己来编写并行代码 goroutine 通过信道（Channel）进行通信；协程通过 yield 和 next操作进行通信 一般来说，goroutine 比协程更强大。而且，我们可以很容易地将协程的逻辑移植到 goroutine 来获得更好的并行效果。
Generators 在 python 中，要实现一个生成器，需要通过 yield 生成数据，通过 next 获取数据：
def integers(): i = 1 while True: yield i i+=1 integerGenerator = integers() next(integerGenerator) # 1 next(integerGenerator) # 2 next(integerGenerator) # 3 同样的，生成器也可以在 Go 中实现，只是使用了 channel 来代替 yield:
func integers () chan int { yield := make (chan int); count := 0; go func () { for { yield &amp;lt;- count; count++; } } (); return yield } next := integers(); func generateInteger () int { return &amp;lt;-next } generateInteger() // 0 generateInteger() // 1 generateInteger() // 2 Iterators go 的 channel 在语法层面就是天然的迭代器。</description></item><item><title>Golang实现Windows系统用户和密码校验</title><link>http://www.vimiix.com/vimiix-blog/posts/2021-03-22-auth-windows-user-in-golang/</link><pubDate>Mon, 22 Mar 2021 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2021-03-22-auth-windows-user-in-golang/</guid><description>本质上是通过调用 windows 的一个 API —— LogonUserW ，来实现对于用户密码的校验。
仅适用于在本地校验，不支持远程连接校验
用一个示例代码来进行说明，下面是目录结构中，main.go 是程序入口文件，auth 包中，我们仅实现 windows 系统的校验代码，其他平台不属于本文介绍内容，就直接返回 nil 即可。
目录结构 . ├── auth │ ├── auth.go │ └── auth_windows.go ├── go.mod └── main.go 源代码 [src] main.go package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.com/vimiix/authDemo/auth&amp;#34; ) func main() { user := flag.String(&amp;#34;u&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;username&amp;#34;) password := flag.String(&amp;#34;p&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;password&amp;#34;) flag.Parse() if *user == &amp;#34;&amp;#34; || *password == &amp;#34;&amp;#34; { fmt.Println(&amp;#34;Both user and password should be specify&amp;#34;) fmt.</description></item><item><title>beanstalkd消息队列</title><link>http://www.vimiix.com/vimiix-blog/posts/2020-03-11-beanstalkd-note/</link><pubDate>Wed, 11 Mar 2020 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2020-03-11-beanstalkd-note/</guid><description>beanstalkd 是一个简单快速的分布式工作队列系统，协议基于 ASCII 编码运行在 tcp 上。其最初设计目的是通过后台异步执行耗时任务方式降低高容量 Web 应用的页面延时。而其简单、轻量、易用等特点，和对任务优先级、延时/超时重发等控制，以及众多语言版本的客户端的良好支持，使其可以很好的在各种需要队列系统的场景中应用。
Beanstalk 的应用场景主要有：
消息异步处理（消息队列的基本需求） 消息延迟处理，实现循环队列 beanstalkd 核心组件 job : 任务，队列中的基本单元 tube : 一个有名称的任务队列，用来存储统一类型的 job ,beanstalkd 通过 tube 来实现多任务队列 producer : job 生产者，通过put命令来创建一个job放到一个tube中 comsumer : job 消费者，通过 reserve、release、bury、delete命令来获取或改变 job 的状态 job 的生命周期 在整个生命周期中 job 可能有四种工作状态：READY、RESERVED、DELAYED、BURIED. 只有处于 READY 状态的 job 才能被消费。
put with delay release with delay -------------&amp;gt; [DELAYED] &amp;lt;---------. | | | (time passes) | | | put v reserve | delete --------------&amp;gt; [READY] -------&amp;gt; [RESERVED] ------&amp;gt; *poof* ^ ^ | | | \ release | | | `-------------&amp;#39; | | | | kick | | | | bury | [BURIED] &amp;lt;---------------&amp;#39; | | delete `--------&amp;gt; *poof* Producer 创建 job 的时候可以选择两种方式：put , put with delay。</description></item><item><title>[译]Richardson成熟度模型</title><link>http://www.vimiix.com/vimiix-blog/posts/2020-02-21-richardson-model/</link><pubDate>Fri, 21 Feb 2020 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2020-02-21-richardson-model/</guid><description>原文链接：https://martinfowler.com/articles/richardsonMaturityModel.html
迈向 REST 的荣耀之巅 Leonard Richardson 提出的一个模型，将实现 REST 方法的主要元素分解为三个步骤，分别包括：资源（Resources）、HTTP 动词(HTTP Verbs，如GET、POST等)和超媒体控制（Hypermedia Controls）。
在Rest In Practice一书中，解释了如何使用 Restful Web Service 来处理企业面临的许多集成问题。本书的核心观点是，Web 就是一个大规模可扩展的分布式系统存在、并可以很好的工作的证明，而我们可以根据这一观点更容易地构建集成系统。
为了说明一个“Web 风格”系统的特定属性，作者使用了由 Leonard Richardson 提出的“RESTful 成熟度模型”，该模型在一次QCon Talk中被谈到。通过这一模型，可以很好的思考如果使用 REST，所以我也会尝试添加一些自己的解释。（本文中所使用协议示例只是为了更好的说明，并不建议在实际生产中编码实现或测试，因为其在细节上可能会存在问题）
Level 0 该模型的出发点是使用 HTTP 作为远程交互的传输系统，但不使用 Web 的任何机制。基本上就是使用 HTTP 作为你远程交互机中的隧道机制，通常基于“远程过程调用”（RPC，Remote Procedure Invocation）。
例如，我想预约我的医生。预约软件首先需要知道在指定日期内医生什么时间有空位，所以它需要向医院预约系统发送请求以获取该信息。在 Level 0 级场景中，医院会将某个 URI 做为一个公共服务点。然后，我就可以向该服务点发送一个文档请求。
POST /appointmentService HTTP/1.1 [various other headers] &amp;lt;openSlotRequest date=&amp;#34;2010-01-04&amp;#34; doctor=&amp;#34;mjones&amp;#34; /&amp;gt; 然后，服务器会返回一个我所需信息的文档：
HTTP/1.1 200 OK [various headers] &amp;lt;openSlotList&amp;gt; &amp;lt;slot start=&amp;#34;1400&amp;#34; end=&amp;#34;1450&amp;#34;&amp;gt; &amp;lt;doctor id=&amp;#34;mjones&amp;#34; /&amp;gt; &amp;lt;/slot&amp;gt; &amp;lt;slot start=&amp;#34;1600&amp;#34; end=&amp;#34;1650&amp;#34;&amp;gt; &amp;lt;doctor id=&amp;#34;mjones&amp;#34; /&amp;gt; &amp;lt;/slot&amp;gt; &amp;lt;/openSlotList&amp;gt; 在本例中我使用了 XML 做为内容格式，实现可以格式的，如：JSON、YAML、键-值对、或其它自定义格式。</description></item><item><title>Golang实现Google在RTB广告中价格加密方案</title><link>http://www.vimiix.com/vimiix-blog/posts/2019-11-13-google-rtb-price-in-golang/</link><pubDate>Wed, 13 Nov 2019 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2019-11-13-google-rtb-price-in-golang/</guid><description>RTB RTB 广告是一种实时竞价广告，就是在针对每个广告位有展示机会的时候，会实时多方竞价，价格最有优势的广告主会竞得这次展示机会，在媒体测在拿到素材的时候，需将本次成交的价格，上报给指定的监控服务器，这时就需要将实时价格按照指定的加密方案加密后，替换 GET 链接中的请求参数中的价格宏来上报。
官方给出的源代码有 Java 和 C++ 版本, 下载地址： https://code.google.com/archive/p/privatedatacommunicationprotocol/source/default/source
本文主要通过 golang 来实现的 google 的价格加密方案。
Source Code package main /* golang 实现 google 的rtb 价格加密方案 https://developers.google.com/authorized-buyers/rtb/response-guide/decrypt-price#encryption-scheme */ import ( &amp;#34;crypto/hmac&amp;#34; &amp;#34;crypto/md5&amp;#34; &amp;#34;crypto/sha1&amp;#34; &amp;#34;encoding/base64&amp;#34; &amp;#34;encoding/binary&amp;#34; &amp;#34;encoding/hex&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;hash&amp;#34; &amp;#34;math&amp;#34; &amp;#34;strings&amp;#34; ) const ( PayloadSize = 8 InitVectorSize = 16 SignatureSize = 4 EKey = &amp;#34;&amp;#34; IKey = &amp;#34;&amp;#34; UTF8 = &amp;#34;utf-8&amp;#34; ) func AddBase64Padding(base64Input string) string { var b64 string b64 = base64Input if i := len(b64) % 4; i !</description></item><item><title>Mac 升级10.12.6 mvim 打开文件报错</title><link>http://www.vimiix.com/vimiix-blog/posts/2019-09-05-mac-sierra-mvim-error/</link><pubDate>Thu, 05 Sep 2019 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2019-09-05-mac-sierra-mvim-error/</guid><description> 当昨天把 Mac 升级了 10.12.6 Sierra 以后，mvim 打开文件的时候就开始报错，使用该方法已解决~
报错信息 dyld: Library not loaded: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib Referenced from: /usr/local/Cellar/macvim/8.0-146/MacVim.app/Contents/bin/../MacOS/Vim Reason: image not found [1] 33114 abort mvim -v 解决方法 这个错误是 macvim 报的错，并非 vim.
➜ vimiix ~ type vim vim is an alias for mvim -v 我这里使用的 vim 指令是对 mvim 的一个别名。
使用一条指令可以解决上面的报错问题：
sudo install_name_tool -change /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/libruby.2.3.0.dylib /usr/local/Cellar/macvim/8.0-146/MacVim.app/Contents/bin/../MacOS/Vim 注意点 需要注意的是，指令最后指定的 vim 路径，一定是上面报错中 Referenced from 后面的路径。参考
相关解答 https://stackoverflow.com/questions/47278449/vim-ruby-mismatch-on-mac-high-sierra</description></item><item><title>Golang如何确保一个类型实现了某个interface</title><link>http://www.vimiix.com/vimiix-blog/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</link><pubDate>Thu, 29 Aug 2019 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</guid><description>在 golang 中，接口（interface）代表一种『协议』存在，它是一个声明了多个方法的集合。
接口是被隐式实现的，也就是说，我们在开发中定义一个类型（type）的时候，不需要声明这个类型实现了哪个接口。在使用的时候往往通过断言来的 ok-idom 来进行类型判断该类型是否实现了目标接口，放置调用方法失败抛出 panic：
if value, ok := AType.(BInterface) { fmt.Println(&amp;#34;ok&amp;#34;) } else { fmt.Println(&amp;#34;no&amp;#34;) } 如果断言失败，那么 ok 的值将会是 false,但是如果断言成功 ok 的值将会是 true,同时 value 将会得到所期待的正确的值。
但是，在某些情况下，我们可能希望明确地检查接口中哪些方法没有被实现。最好的方法就是借助编译器地检查功能。
假设定义了一个 Programmer 接口，一个 Human 类型：
&amp;raquo;&amp;gt; 试一下
package main type Programmer interface { Code() string } type Human struct {} func main() {} 这段代码没有做任何操作，可以正常地执行。
假设我们希望 Human 类型实现了 Programmer 接口，可以在代码中定义一个 _ （下划线表示忽略这个变量）变量来实现检测效果
package main type Programmer interface { Code() string } type Human struct {} // 利用编译器检查接口实现 var _ Programmer = (*Human)(nil) func main() {} 当再次执行这段代码地时候，就会报出如下编译错误：</description></item><item><title>HLS视频加密</title><link>http://www.vimiix.com/vimiix-blog/posts/2019-03-28-use-hls-to-encrypt-video/</link><pubDate>Thu, 28 Mar 2019 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2019-03-28-use-hls-to-encrypt-video/</guid><description>&lt;blockquote>
&lt;p>最近在做视频管理后台，主要提供点播服务，涉及到需要对视频进行加密处理以防止视频被随意下载。&lt;/p>
&lt;p>调研了一番之后确定使用 HLS(HTTP Live Streaming) 基于 HTTP 的流媒体网络传输协议技术来处理视频。&lt;/p>
&lt;p>所以本文主要记录关于学习 HLS 视频加密技术的笔记&lt;/p>
&lt;/blockquote>
&lt;h3 id="为什么要加密">为什么要加密？&lt;/h3>
&lt;p>简单的说就是：增加获取被加密资源的代价。对于视频这种资源来说，绝对的加密就是不要上线给人看，但那是不可能的，因为提供的服务就是给人看视频，只要上线，别人就可以通过各种手段解密或者简单的录屏的方式来传播，所以目前俩看，不存在绝对的加密。只要让恶意的人获取源视频的代价很大，就可以阻挡绝大多数的不法分子。这样，加密的目的也就基本达到了。&lt;/p></description></item><item><title>获取存储在又拍云CDN中视频的时长</title><link>http://www.vimiix.com/vimiix-blog/posts/2019-01-30-get-video-duration-by-upyun-sdk/</link><pubDate>Wed, 30 Jan 2019 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2019-01-30-get-video-duration-by-upyun-sdk/</guid><description>&lt;h3 id="前置条件">前置条件&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>可用的账户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装又拍云 Python 版本的 SDK：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>pip install upyun
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（官方代码开源地址：&lt;a href="https://github.com/upyun/python-sdk/">https://github.com/upyun/python-sdk/&lt;/a> )&lt;/p></description></item><item><title>快速切换本地Git用户记录</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-11-08-change-git-account-by-script/</link><pubDate>Thu, 08 Nov 2018 23:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-11-08-change-git-account-by-script/</guid><description>&lt;p>现在大部分的科技公司开发模式，都是基于 Git 进行多人协作开发。所以，对于我们每一个开发者来说，Git 的操作就是必不可少的技能了（不是锦上添花，而是必不可少）。对于 Git 的操作，不是本次记录的内容，网上的&lt;a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-Git-%E5%9F%BA%E7%A1%80">教程&lt;/a>可以在官网找到。&lt;/p>
&lt;p>今天我想记录一下我本机多用户管理的一点小操作。&lt;/p>
&lt;p>当每进入一家新公司的时候，总会在新公司领到一个新的公司邮箱，基本上这个邮箱也就是你在公司期间进行代码开发的 git 账户。这时候，加上我们平时在 &lt;a href="https://github.com">GitHub&lt;/a> 的账户，就会有两个账户需要切换使用。&lt;/p>
&lt;p>下面是我个人的一点小技巧记录，不一定是最好的，但只要自己用着方便就 OK，如果此时看文章的你有好的方法的话，可以请在讨论区交流。&lt;/p></description></item><item><title>从七牛云到阿里云的自动化迁移代码说明</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-10-29-move-qiniuyun-to-alioss-analysis/</link><pubDate>Mon, 29 Oct 2018 23:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-10-29-move-qiniuyun-to-alioss-analysis/</guid><description>&lt;p>前几天叙事性的写了&lt;a href="https://vimiix.com/post/2018/10/24/move-qiniuyun-to-alioss/">一篇&lt;/a>，有点像日记，这篇分析一下代码逻辑，便于以后回顾。&lt;/p>
&lt;h3 id="工具">工具&lt;/h3>
&lt;ul>
&lt;li>python3.5&lt;/li>
&lt;li>顺手的 IDE（轻量级推荐&lt;a href="https://code.visualstudio.com/">vscode&lt;/a>）&lt;/li>
&lt;li>&lt;a href="https://github.com/qiniu/qshell#%E4%B8%8B%E8%BD%BD">qiniu/qshell&lt;/a> （本文是基于 mac 系统开发，所以使用 qshell 的 mac 版本，读者请根据自己的系统下载，也可以直接跳至文末，下载本文源码，源码中 tool 文件夹中已经下载好了 mac 下的工具。这个工具只有一步使用到，所以如果只是使用一下，可以不用研究他的所有指令）&lt;/li>
&lt;/ul></description></item><item><title>七牛云数据自动迁移到阿里云OSS</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-10-24-move-qiniuyun-to-alioss/</link><pubDate>Wed, 24 Oct 2018 19:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-10-24-move-qiniuyun-to-alioss/</guid><description>&lt;h3 id="背景">背景&lt;/h3>
&lt;p>近期收到两封七牛云发来的邮件：&lt;/p>
&lt;blockquote>
&lt;p>测试域名回收通知&lt;/p>
&lt;p>您的账号 xxx 在七牛云融合 CDN 加速平台有以下测试域名&lt;strong>还剩 7 个自然日会被系统自动回收&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>由于，我博客所有的图片文件都是存储在七牛云的，这个域名也使用了一年多了，怎么突然要回收呢？&lt;/p>
&lt;p>上网一搜才知道，大概是有什么不法分子之类的，使用七牛云的免费空间传播色情暴力之类的内容，被 Godday 制裁了，现在新申请的 bucket 只能使用一个月，要想绑定域名，还得备案操作。俺这小博客，也就自己玩玩的一个国外服务器，也备不了案啊。&lt;/p>
&lt;p>无奈，看网上很多人都是被回收了才知道自己的图片都访问不了。还好我习惯性的看这些推送邮件，给自己留了一周时间用来备份转移。既然免费的不好用了，微博之类的图床不好迁移，所以就买了一年阿里云的 OSS 服务。&lt;/p>
&lt;p>虽然我的图片还算不是很多，但要是一张一张手动下载再上传到阿里云，也是不小的工作量，而且太浪费时间了。&lt;/p></description></item><item><title>pipenv错误解决:TypeError: "module" object is not callable</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-10-21-solution-of-pipenv-install-error/</link><pubDate>Sun, 21 Oct 2018 11:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-10-21-solution-of-pipenv-install-error/</guid><description>&lt;h3 id="软件版本">软件版本&lt;/h3>
&lt;p>今天在折腾一台新的云主机，所以我在安装环境的时候&lt;code>pip&lt;/code>和&lt;code>pipenv&lt;/code>都选择安装了最新版本&lt;/p>
&lt;p>（&lt;em>注：正是这两个版本配合才会出现下面的报错，旧版本或以后的新版本的 Pipenv 不会出现&lt;/em>）。&lt;/p>
&lt;p>具体如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>// pipenv 的版本 2018.7.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pipenv --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pipenv, version 2018.7.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// pip 的版本 18.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pip --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pip 18.1 from /usr/bin/python3.6/lib/python3.6/site-packages/pip &lt;span style="color:#f92672">(&lt;/span>python 3.6&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>macOXS中使用matplotlib遇到的问题及探究</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-10-16-explore-the-problem-of-matplotlib-on-macosx/</link><pubDate>Tue, 16 Oct 2018 11:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-10-16-explore-the-problem-of-matplotlib-on-macosx/</guid><description>&lt;p>第一次在 mac 系统上使用&lt;strong>matplotlib&lt;/strong>库的时候，在执行的时候，往往会遇到下面这样的问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ImportError: Python is not installed as a framework. balabala....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>当然这个问题很好解决，网上有一搜就会找到如下两种解决方案：&lt;/p>
&lt;h4 id="第一种方案是在系统中设置">第一种方案是在系统中设置：&lt;/h4>
&lt;ul>
&lt;li>假设你已经通过&lt;code>pip install matplotlib&lt;/code>安装了 matplotlib，那么在你的根目录中会有一个名为&lt;code>〜/ .matplotlib&lt;/code>的目录。&lt;/li>
&lt;li>在这个目录中创建一个&lt;code>matplotlibrc&lt;/code>的文件 ,在里面添加一行代码：&lt;code>backend: TkAgg&lt;/code>，保存退出即可。&lt;/li>
&lt;/ul>
&lt;p>总结为一行 shell 命令就是：&lt;code>echo &amp;quot;backend: TkAgg&amp;quot; &amp;gt;&amp;gt; ~/.matplotlib/matplotlibrc&lt;/code>&lt;/p>
&lt;p>这种方式可以设定整个系统的 matplotlib 渲染使用的引擎，但是不好的是，代码会变得不可移植，如果服务器很多，我们需要每一台机器都去设置这个参数，这时候就需要使用第二种方案。&lt;/p>
&lt;h4 id="第二种方案是在代码中设置">第二种方案是在代码中设置：&lt;/h4>
&lt;p>在引用&lt;code>matplotlib&lt;/code>库的代码之前，添加如下两行代码（确认安装 TkInter）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> matplotlib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>matplotlib&lt;span style="color:#f92672">.&lt;/span>use(&lt;span style="color:#e6db74">&amp;#39;TkAgg&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样也可以临时的修改前面提到的 &lt;code>backend&lt;/code>变量。&lt;/p></description></item><item><title>[译]实践出真知</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-10-10-dont-just-learn-a-new-language-framework-implement-it-as-a-running-open-source-project/</link><pubDate>Wed, 10 Oct 2018 23:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-10-10-dont-just-learn-a-new-language-framework-implement-it-as-a-running-open-source-project/</guid><description>Aristotle（亚里士多德），希腊著名的哲学家和科学家，曾经说过：“对于那些我们在能做到之前必须学习如何做的事情，我们需要边做边学 (For the things we have to learn before we can do them, we learn by doing them.)”。想象一下，假如你已经读过 3 本关于骑行的书了，然后有人给你一辆自行车并让你骑它，你能骑吗？很显然，答案是“不能”。这无关乎你曾经读了多少关于骑行的书或你看了多少相关视频的事情。它需要你真正骑上一辆自行车，去保持平衡，去学习脚，手和眼睛的协调配合才能掌握的一件事情。学习新技术，新语言或框架同样也是如此。
如果现在你在想：我都不会某个语言或某个框架，我要怎么去实现这个开源项目呢，那么先停止抱怨。也许你是技术或编程的新手，但你需要知道如何去学习新事物。学习新东西的最好方法就是实践。这篇文章将重点关注普适通用的方法。它会帮助你从我想要学习&amp;rsquo;X&amp;rsquo;到我有一个项目在&amp;rsquo;X&amp;rsquo;运行，所以继续往下看。如果你决定通过做一个项目来学习新东西，那就把它开源吧。Github 是托管你的开源项目的首选服务商。在其上你可以享受很多的免费服务。这篇文章的编写主要面向编程起步者，但对于经验丰富的软件工程师也同样有用。
摘要（TLDR;） 通过编写项目来学习语言/框架，然后使用免费使用服务开源出去。不要只看课程，阅读文档，然后找到解决方案就完事，实践出真知。在项目中去使用 git 并尽量 docker 化。代码需要添加正确的代码质量检查服务以找到最佳实践，将项目部署到服务器上，让其可以对外通过 URL 访问。
不要只看课程，阅读文档，找到解决方案就完事 如今，学习新知识有很多选择。视频课程仍然是最受欢迎的媒介之一。你可以在Udemy，Pluralsight甚至Youtube上学习。在你边做边学之前，观看视频只会在某种程度上有所帮助，更好的方式是阅读官方手册。例如，阅读 React JS 文档比仅通过观看 React JS 课程更好。这样你会发现创作者的思想在其中。理清创作一个 Javascript 框架/库背后的逻辑会帮助你找到最合适的解决方案。
学习使用 Git 进行协作 “没有谁是一座孤岛” ，特别是在技术方面，你通常不会单独工作，肯定是作为团队的一员。因此，即使在学习新内容时，也要尝试找可以一起合作的人。与其它流行的代码协作工具相比，Git 非常受欢迎。当有超过 1 人为项目编写代码时，它是很有用的。你应该通过实践学习 git，可以通过查看Github 教程。我强烈推荐边做边学。当你将代码推送到 Github 之后，任何人都可以为你的项目贡献力量。
实现 docker 化，克服我的机器综合症 都8102 年了，如果你想让你的应用程序更易于使用，请使用Docker。这对于增加对开源项目的贡献也有很大帮助。使用docker compose在本地运行项目就像执行 2 个命令一样。Docker 有很多优点。对于初学者来说，这是一种确保你的应用可以在其他人的机器上以相同的方式运行的方法。在你部署应用程序的服务器上也是如此。只要它在 Docker 上运行良好，你就大可以放心，它保证可以在任何环境中无问题地运行。
添加代码质量检查 只是让你的项目能够运行不应该是你的最终目标。代码质量，稳定性等也应该是你追求的一个指标。你需要给你准备开源的项目添加代码质量检查流程（单元测试是必不可少的）。根据语言/框架，你可以选择任何服务。我推荐Code Climate。Code Climate 支持各种语言，从 Javascript 到 PHP，从 Java / Kotlin 到 Swift，适用于移动开发人员。通过最新的浏览器插件，你可以在 Github 的 PR 界面直观的查看关于代码的检查情况。只需将其连接一次到你的 Github 仓库，就可以开始查看的你的代码质量报告。然后你就可以通过这个来改良你的代码。举个例子。</description></item><item><title>[译]通过HTTPS协议运行你的Flask程序</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-08-27-running-your-flask-application-over-https/</link><pubDate>Mon, 27 Aug 2018 17:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-08-27-running-your-flask-application-over-https/</guid><description>&lt;p>我们在开发 Flask 应用程序时，通常通过运行 Flask 自带的 Web 服务器来开发测试，这个服务器提供了基本的但功能完备的 WSGI 服务器。但开发结束以后，在应用程序上线到生成环境时，有很多不得不考虑的事情，其中之一是我们是否应该要求客户端使用加密连接以增加安全性。&lt;/p>
&lt;p>人们总是问我这个问题，特别是如何在 HTTPS 协议上部署 Flask 服务器。在本文中，我将介绍几种为 Flask 应用程序添加加密的方案，从一个非常简单的可以在五秒内实现，到一个强大的就像我的网站一样可以得到一个 A +评级解决方案（&lt;a href="https://www.ssllabs.com/ssltest/analyze.html?d=blog.miguelgrinberg.com">我的网站的 SSL 分析数据&lt;/a>）。&lt;/p></description></item><item><title>Git开发记录-合并多条commit最佳实践</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-08-13-git-best-practice/</link><pubDate>Mon, 13 Aug 2018 19:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-08-13-git-best-practice/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>常规的多人基于 GIT 协作开发的时候，都是遵循先 fork 一份主版本代码到自己的账号下面，然后基于本账户的版本，开分支来开发功能或修 Bug，完成以后再讲修改的内容，提交一个完整的 PR 贡献回主版本。&lt;/p>
&lt;p>在本分支上开发的过程中，有时候不得不先提交到自己账号下面的克隆版本中来测试（比如豆瓣的&lt;code>dae pre&lt;/code>，无法在本地生成预览，需要提交到远端），我们不能保证一次性提交就做到完美，避免不了会往复的修改后提交，这样的一次次测试用的 commit 属于是冗余的琐碎信息，对于主版本迭代是没有价值的。如果直接在基于该分支提交 PR，甚至被&lt;code>merge&lt;/code>到&lt;code>upstream/master&lt;/code>主版本中，这些不必要的 commit 信息也会包含进主版本中。这当然不是一个理想的迭代方式。&lt;/p>
&lt;p>现在问题明确以后，就是一个目标：&lt;strong>将这些开发中的所有 commit 都合并为一条有意义的 commit 信息提交给主版本&lt;/strong>。&lt;/p></description></item><item><title>Django Channels2.0 websocket最佳实践</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-07-26-channels2-tutorial/</link><pubDate>Thu, 26 Jul 2018 02:56:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-07-26-channels2-tutorial/</guid><description>&lt;p>做 web 后端开发，少不了要和 websocket 打交道。之前写过一篇关于 websocket 的实践文章 &amp;mdash; &lt;a href="https://vimiix.com/post/2018/04/02/python-websocket/">《[python]记录关于 websocket 的原理和使用》&lt;/a> ，不过，从 GITHUB 上可以看到，&lt;strong>django-websocket&lt;/strong> 这个开源项目俨然已经是一个被放弃了的坑，并且在使用的过程中确实也有很多坑，果断弃之。&lt;/p>
&lt;p>今天想聊的就是目前业界大牛都在推荐的一个框架&amp;ndash;&lt;a href="https://github.com/django/channels">Channels&lt;/a>， Channels 是针对 Django 项目的一个增强框架，它可以是的同步的 Django 项目转变为异步的项目。它可以使得 Django 项目不仅支持 HTTP 请求，还可以支持 Websocket, chat 协议，IOT 协议 ，甚至是你自定义的协议，同时也整合了 Django 的 auth 以及 session 系統等等。&lt;/p></description></item><item><title>浅谈Python中的上下文管理</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-07-17-learn-contextlib/</link><pubDate>Wed, 18 Jul 2018 00:56:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-07-17-learn-contextlib/</guid><description>&lt;h2 id="with-语法">with 语法&lt;/h2>
&lt;p>平常在写 Python 代码的时候，经常会用到&lt;code>with&lt;/code> 来处理一个上下文环境，比如文件的打开关闭，数据库的连接关闭等等。&lt;/p>
&lt;p>&lt;code>with&lt;/code>语法的使用，需要我们处理的对象实现&lt;code>__enter__&lt;/code>和&lt;code>__exit__&lt;/code>两个魔术方法来支持。&lt;code>__enter__&lt;/code>函数处理逻辑函数之前需要做的事情，并返回操作对象作为&lt;code>as&lt;/code>后面的变量，&lt;code>__exit__&lt;/code>函数处理当代码离开&lt;code>with&lt;/code>代码块以后的事情。&lt;/p>
&lt;p>&lt;code>with&lt;/code>语法非常方便的让我使用资源并且不用操心忘记后续操作所带来的隐患。&lt;/p></description></item><item><title>《算法图解》读书笔记7-狄克斯特拉算法</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-06-05-grokking-algorithms-chapter-7/</link><pubDate>Mon, 16 Jul 2018 22:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-06-05-grokking-algorithms-chapter-7/</guid><description>&lt;h2 id="概念">概念&lt;/h2>
&lt;blockquote>
&lt;p>狄克斯特拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题 (该算法不能处理包含负边的图)。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。&lt;/p>
&lt;/blockquote></description></item><item><title>跳槽</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-07-02-wake-up-time/</link><pubDate>Mon, 02 Jul 2018 14:36:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-07-02-wake-up-time/</guid><description>不知不觉，一个月没有写东西。感觉很快，因为没有感觉；但又感觉很慢，因为心理一直在作斗争。
这将近一个月的时间里，我基本没有和圈内的朋友交流，自己都感觉自己像蒸发了一样。这一个月的经过，给我积累了人生的一次重要经验——项目一定要选对人。剩下的就留给时间去消化吧。
今天以后，我将继续恢复日常的上班，学习，记录生活。
今天，北京天气很好。趁着阳光正好，我正式入职豆瓣了。
豆瓣，因为喜欢 python，慕名而来。
希望自己未来可以在这个 python 的&amp;quot;伊甸园&amp;quot;里面茁壮地成长！</description></item><item><title>[译]python中垃圾回收和析构函数笔记</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-06-04-python-destructor-and-garbage-collection-notes/</link><pubDate>Mon, 04 Jun 2018 14:36:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-06-04-python-destructor-and-garbage-collection-notes/</guid><description>&lt;blockquote>
&lt;p>紧接上一篇转载的文章&lt;a href="https://vimiix.com/post/2018/06/04/python-magic-methods/">《Python 魔术方法总结》&lt;/a>文末提及的英文参考文章，洒家顺手就翻译了一下。方便墙内的同学学习。这篇文章不仅指出了 Python 如何处理垃圾回收，还提到了我们作为程序员不应该只借助现代化 IDE 的函数提示功能去完成代码，应该多去看官方的完整文档，可以知道哪些函数被废弃的，哪些函数在使用时需要注意什么等等一些很重要的信息。话不多说，自己体会，请向下阅读文章吧。&lt;/p>
&lt;p>原文链接：&lt;a href="https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/">https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>我很少在 Python 对象中使用析构函数。我猜 Python 的动态特性往往弱化了对析构函数的需求。但是现在，假如我需要在对象被销毁时，或者更确切地说，当程序退出时，要将一些数据写入磁盘。这时我会使用&lt;code>__del__&lt;/code> 魔术方法在主要操作的类对象中定义了一个析构函数。但是奇怪的是，这个析构函数自始至终都没有被调用到。不仅在程序退出时没有被调用到，而且我手动使用&lt;code>del&lt;/code>删除时也不会被调用。由于这个程序是我前一段时间写的，所有稍微有点不是很熟悉了，这导致我怀疑是我程序中有一个大的 BUG 存在。&lt;/p></description></item><item><title>[转]Python中的魔术方法汇总</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-06-04-python-magic-methods/</link><pubDate>Mon, 04 Jun 2018 13:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-06-04-python-magic-methods/</guid><description>&lt;blockquote>
&lt;p>这是一篇很不错的总结文章，简单易理解，洒家忍不住要转载收藏一下。&lt;/p>
&lt;p>源文链接：&lt;a href="http://algo.site/?cat=60">http://algo.site/?cat=60&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="基础">基础:&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>如果你想…&lt;/th>
&lt;th>所以,你写…&lt;/th>
&lt;th>Python 调用…&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>初始化一个实例&lt;/td>
&lt;td>&lt;code>x = MyClass()&lt;/code>&lt;/td>
&lt;td>&lt;code>x.__init__()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>作为一个字符串的&amp;quot;官方&amp;quot;表示&lt;/td>
&lt;td>&lt;code>repr(x)&lt;/code>&lt;/td>
&lt;td>&lt;code>x.__repr__()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>作为一个字符串&lt;/td>
&lt;td>&lt;code>str(x)&lt;/code>&lt;/td>
&lt;td>&lt;code>x.__str__()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>作为字节数组&lt;/td>
&lt;td>&lt;code>bytes(x)&lt;/code>&lt;/td>
&lt;td>&lt;code>x.__bytes__()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>作为格式化字符串&lt;/td>
&lt;td>&lt;code>format(x, format_spec)&lt;/code>&lt;/td>
&lt;td>&lt;code>x.__format__(format_spec)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>《算法图解》读书笔记6-图以及广度优先搜索</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-06-03-grokking-algorithms-chapter-6/</link><pubDate>Sun, 03 Jun 2018 16:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-06-03-grokking-algorithms-chapter-6/</guid><description>&lt;h2 id="什么是图">什么是图&lt;/h2>
&lt;p>图模拟一组链接，图由顶点和边组成。一个顶点可能与众多顶点直接相连，这些顶点被称为&lt;strong>邻居&lt;/strong>。&lt;/p>
&lt;p>图通常表示为：&lt;code>G(V,E)&lt;/code>，其中，&lt;code>G&lt;/code>表示一个图，&lt;code>V&lt;/code>是图中顶点的集合，&lt;code>E&lt;/code>是图中边的集合。&lt;/p>
&lt;h4 id="简单图">简单图&lt;/h4>
&lt;p>在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则这样的图称之为简单图。&lt;/p>
&lt;h4 id="无向图">无向图&lt;/h4>
&lt;p>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。&lt;/p>
&lt;p>无向边：若顶点 M 到顶点 N 的边没有方向，称这条边为无向边，用无序偶对(M,N)或(N,M)表示。&lt;/p></description></item><item><title>《算法图解》读书笔记5-散列函数及扩展</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-06-02-grokking-algorithms-chapter-5/</link><pubDate>Sat, 02 Jun 2018 16:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-06-02-grokking-algorithms-chapter-5/</guid><description>&lt;h2 id="散列函数">散列函数&lt;/h2>
&lt;p>散列函数就是一种&lt;strong>映射&lt;/strong>，是从关键字到存储地址的映射。通常，包含散列函数的算法的算法复杂度都为 O(1)，对应到 Python 中的数据结构就是字典，给一个 key 可以得到一个固定的 value 值。散列函数必须满足一些要求：&lt;/p>
&lt;ul>
&lt;li>它必须是一直的。例如，假设输入 apple 时得到的是 4，那么每次输入 apple 时，都必须是 4，不然这个散列函数就是无意义的；&lt;/li>
&lt;li>散列函数应该将不同的输入值，对应到不同的值上。（虽然不同的 key 对应相同的 value 是允许的，但最理想的情况是不同的 key，对应不同的 value，这种称之为&lt;a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97">完美散列&lt;/a>）&lt;/li>
&lt;/ul></description></item><item><title>《算法图解》读书笔记4-分治思想和快排</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-05-30-grokking-algorithms-chapter-4/</link><pubDate>Wed, 30 May 2018 16:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-05-30-grokking-algorithms-chapter-4/</guid><description>&lt;h2 id="分而治之divide-and-conquer">分而治之（Divide and Conquer）&lt;/h2>
&lt;p>所谓分而治之，分为分解问题，但我们目的是解决大问题，所有还有将分解后得到的结果贡献回大问题，最终使得我们解决大问题。&lt;/p>
&lt;p>分而治之的思想是采用了递归的思想，将原问题分成几个规模较小但是&lt;strong>类似&lt;/strong>于原问题的子问题， 通过递归的方式来求解这些小问题，最后将子问题的解合并来得到原问题的解。分治思想的本质是我们中学时候学的数学归纳法。&lt;/p>
&lt;p>书上提到，使用分治思想解决问题的过程包括两个步骤，其实应该是三个步骤：&lt;/p>
&lt;ol>
&lt;li>找出基线条件，这种条件必须尽可能简单。&lt;/li>
&lt;li>不断将问题分解为子问题（或者说缩小规模），直达符合基线条件。&lt;/li>
&lt;li>合并子问题的结果，得到最终问题的解（利用系统栈的特性实现过程状态的记录）&lt;/li>
&lt;/ol></description></item><item><title>《算法图解》读书笔记2-数组链表和选择排序</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-05-25-grokking-algorithms-chapter-2/</link><pubDate>Fri, 25 May 2018 19:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-05-25-grokking-algorithms-chapter-2/</guid><description>&lt;h2 id="理解数组和链表">理解数组和链表&lt;/h2>
&lt;p>链表和数组是两种基本的数据结构，他们的区别在于数据在内存中的存储方式不同。&lt;/p>
&lt;h3 id="数组">数组&lt;/h3>
&lt;p>数组在内存中是用一块连续的内存来存储数据的，数组中的每个数据地址是连续的。数组中的每个元素所占用的内存是相同的，所以，我们可以通过下标索引在常数数量级的时间内，迅速访问数组中的任何一个元素。但是要在数组中任意位置添加一个元素，就需要移动大量的元素，使得内存中空出一个位置来存放新插入的元素。同理，当删除一个元素的时候，也需要移动大量的元素，来使得删除元素以后的数组数据在内存中仍旧是连续的。&lt;/p>
&lt;p>由此可见：当对于一组数据，读取操作频繁，写操作少的情况，应该使用数组数据结构。&lt;/p></description></item><item><title>《算法图解》读书笔记3-递归</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-05-27-grokking-algorithms-chapter-3/</link><pubDate>Fri, 25 May 2018 19:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-05-27-grokking-algorithms-chapter-3/</guid><description>&lt;blockquote>
&lt;p>如果使用循环 ，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。&lt;/p>
&lt;/blockquote>
&lt;h2 id="递归函数">递归函数&lt;/h2>
&lt;p>在一个函数中，可以调用另一个函数，如果调用的另一个函数是函数本身，这样的函数就是递归函数。如下示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;end&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 在函数中继续调用自己&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> foo(x&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>《算法图解》读书笔记1-二分和大O</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-05-21-grokking-algorithms-chapter-1/</link><pubDate>Wed, 23 May 2018 23:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-05-21-grokking-algorithms-chapter-1/</guid><description>&lt;blockquote>
&lt;p>算法是一组完成任务的指令&lt;/p>
&lt;/blockquote>
&lt;h2 id="为什么要学习算法">为什么要学习算法&lt;/h2>
&lt;p>这次是我第二次读《算法图解》，当我第一次看这本书的时候，我更兴奋于书中有什么内容，迫不及待的去过内容，学习那些算法概念。但当我第二次准备开始读这本书的时候，我脑海中出现的了一个问题：“为什么要学习算法？”，这个问题也许会有人和我一样，之前根本没有好好的去思考，只是知道，作为一个程序员我应该学习算法。当然，能够有这个觉悟，说明我们还算是个合格的程序员。&lt;/p>
&lt;p>但是，不妨认真思考一下，为什么要学习算法？算法应该怎么学？&lt;/p></description></item><item><title>TLPI笔记—深入文件I/O模型</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-05-18-tpli-io-extend/</link><pubDate>Fri, 18 May 2018 09:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-05-18-tpli-io-extend/</guid><description>&lt;h2 id="原子操作和竞争操作">原子操作和竞争操作&lt;/h2>
&lt;p>所有的系统调用都是以原子操作方式执行的。之所以这么说，是指内核保证了某系统调用中的所有步骤会作为地理操作而一次性加以执行，期间不会被其他进程或线程中断。原子性规避了&lt;strong>竞争状态（race condition）&lt;/strong>，竞争状态指：操作共享资源的两个进程（或线程）其结果取决于一个无法预期的顺序，即这些进程或线程获得 CPU 使用权的先后相对顺序。&lt;/p></description></item><item><title>TLPI笔记—通用文件I/O模型</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-05-11-tpli-common-io/</link><pubDate>Fri, 11 May 2018 09:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-05-11-tpli-common-io/</guid><description>&lt;h2 id="文件描述符">文件描述符&lt;/h2>
&lt;p>所有执行 I/O 操作的系统调用都是以文件描述符，一个非负整数来指代打开的文件。文件描述符用以表示所有类型的已打开的文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。每个进程都各自独立维护着一张文件描述符表。&lt;/p>
&lt;h3 id="标准文件描述符">标准文件描述符&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">文件描述符&lt;/th>
&lt;th style="text-align:center">用途&lt;/th>
&lt;th style="text-align:center">POSIX 名称&lt;/th>
&lt;th style="text-align:center">stdio 流&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">标准输入&lt;/td>
&lt;td style="text-align:center">STDIN_FILENO&lt;/td>
&lt;td style="text-align:center">stdin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">标准输出&lt;/td>
&lt;td style="text-align:center">STDOUT_FILENO&lt;/td>
&lt;td style="text-align:center">stdout&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">标准错误&lt;/td>
&lt;td style="text-align:center">STDERR_FILENO&lt;/td>
&lt;td style="text-align:center">stderr&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>TPLI笔记—linux/unix标准和历史</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-05-01-linux-history/</link><pubDate>Tue, 01 May 2018 19:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-05-01-linux-history/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近开始阅读&lt;a href="https://book.douban.com/subject/25809330/">《Linux/Unix 系统编程手册》&lt;/a> 这本书，重新系统的学习一下 linux 系统编程方面的知识。&lt;/p>
&lt;p>在阅读完第一章《历史和标准》以后，对于很多标准名词都见过，但是对于他们之间的发展历程很是模糊，通读这部分内容后豁然开朗，尤其本章最后总结部分，对于前面的概况的既简练还没有遗漏。不禁在书上用笔写下：&lt;strong>“牛 B 总结，一气呵成”&lt;/strong>。&lt;/p>
&lt;p>方便以后不去翻书回顾，特花点时间摘录至此。&lt;/p></description></item><item><title>[python]记录关于websocket的原理和使用</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-04-02-python-websocket/</link><pubDate>Mon, 02 Apr 2018 19:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-04-02-python-websocket/</guid><description>&lt;h2 id="什么是-websocket">什么是 websocket&lt;/h2>
&lt;p>WebSocket 是一种在单个 TCP 连接上进行&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5">全双工&lt;/a>通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建&lt;strong>持久性&lt;/strong>的连接，并进行双向数据传输。&lt;/p>
&lt;p>Websocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说的。&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;blockquote>
&lt;p>HTTP 的生命周期通过 Request 来界定，也就是发送一次 Request，收到一次 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了&lt;/p>
&lt;p>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response ， 在 HTTP 中永远是这样，也就是说一个 request 只能有一个 response。而且这个 response 也是被动的，不能主动发起。&lt;/p>
&lt;p>而对于 websocket 来说，在 HTTP 的握手基础上建立起链接，服务器端可以主动的向客户端发送数据。&lt;/p>
&lt;/blockquote></description></item><item><title>[笔记]git push卡主不动问题记录：Git push hangs on POST git-receive-pack</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-03-18-git-push-hangs-on-chunked/</link><pubDate>Sun, 18 Mar 2018 18:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-03-18-git-push-hangs-on-chunked/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>昨天完成了&lt;a href="https://github.com/pythonzhichan/django-beginners-guide/blob/master/ClassBasedViews.md">《一个完整的 Django 入门指南》 - 第 6 部分&lt;/a>的翻译工作，本地在翻译的过程中，存储了十几张原文中的 &lt;code>png&lt;/code> 格式的插图。&lt;/p>
&lt;p>在 &lt;code>git push&lt;/code> 提交 &lt;strong>github&lt;/strong> 仓库的时候，终端显示写成功 100%, 但是一直卡在了下面这里没有推送成功：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Counting objects: 21, &lt;span style="color:#66d9ef">done&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Delta compression using up to &lt;span style="color:#ae81ff">8&lt;/span> threads.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Compressing objects: 100% &lt;span style="color:#f92672">(&lt;/span>21/21&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#66d9ef">done&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Writing objects: 100% &lt;span style="color:#f92672">(&lt;/span>21/21&lt;span style="color:#f92672">)&lt;/span>, 1018.52 KiB | 17.87 MiB/s, &lt;span style="color:#66d9ef">done&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total &lt;span style="color:#ae81ff">21&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 7&lt;span style="color:#f92672">)&lt;/span>, reused &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 卡在这里&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[Python]使用pipenv管理python虚拟环境</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-03-11-manage-your-virtualenv-with-pipenv/</link><pubDate>Sun, 11 Mar 2018 18:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-03-11-manage-your-virtualenv-with-pipenv/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>近期的项目中，我开始尝试着从 virtualenv 管理 python 虚拟环境，切换到用 pipenv 来管理。&lt;/p>
&lt;p>经过一段时间的使用，着实觉得 pipenv 使用的更加顺手，更加的便捷。这当然也延续了 &lt;a href="https://www.kennethreitz.org/">Kenneth&lt;/a> 大神一贯的项目作风&amp;ndash; &lt;strong>&lt;code>For Humans&lt;/code>&lt;/strong> 。&lt;/p>
&lt;p>再配合上 &lt;strong>&lt;code>autoenv&lt;/code>&lt;/strong>（自动激活虚拟环境的工具），更加的 Perfect！&lt;/p></description></item><item><title>[Python]Uvicorn初体验</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-02-26-first-practise-of-uvicorn/</link><pubDate>Mon, 26 Feb 2018 12:20:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-02-26-first-practise-of-uvicorn/</guid><description>&lt;h2 id="uvicorn-简介">uvicorn 简介&lt;/h2>
&lt;p>&lt;code>uvicorn&lt;/code>是一个基于&lt;code>asyncio&lt;/code>开发的一个轻量级高效的 web 服务器框架。&lt;/p>
&lt;blockquote>
&lt;p>官网：&lt;a href="http://www.uvicorn.org">http://www.uvicorn.org&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>uvicorn&lt;/code> 设计的初衷是想要实现两个目标：&lt;/p>
&lt;ul>
&lt;li>使用&lt;a href="https://github.com/MagicStack/uvloop">&lt;code>uvloop&lt;/code>&lt;/a>和&lt;a href="https://github.com/MagicStack/httptools">&lt;code>httptools&lt;/code>&lt;/a>实现一个极速的&lt;code>asyncio&lt;/code>服务器。&lt;/li>
&lt;li>实现一个基于&lt;a href="http://channels.readthedocs.io/en/stable/asgi.html">&lt;code>ASGI(异步服务器网关接口)&lt;/code>&lt;/a>的最小的应用程序接口。&lt;/li>
&lt;/ul>
&lt;p>它目前支持&lt;code>http&lt;/code>，&lt;code>websockets&lt;/code>，&lt;code>Pub/Sub&lt;/code> 广播，并且可以扩展到其他协议和消息类型。&lt;/p></description></item><item><title>[算法笔记]动态规划之最长公共子串和最长公共子序列</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-02-07-dp-note/</link><pubDate>Wed, 07 Feb 2018 12:27:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-02-07-dp-note/</guid><description>&lt;blockquote>
&lt;p>本文是《算法图解》笔记&lt;/p>
&lt;/blockquote>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;p>一切脱离实际应用场景的算法都是耍流氓！&lt;/p>
&lt;ul>
&lt;li>生物学家根据最长公共序列来确定 DNA 链的相似性，进而判断两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。&lt;/li>
&lt;li>源代码管理中，&lt;code>git diff&lt;/code>指令，可以查找出编辑前后文件的差异，这是基于动态规划实现的。&lt;/li>
&lt;li>编辑距离（&lt;code>levenshtein distance&lt;/code>），判断字符串的相似程度，也是基于动态规划计算。可以通过这个技术从拼写检查到判断用户上传的资料是否是盗版。（&lt;em>这样看来，我猜想大学论文查重应该也是基于动态规划算法:P&lt;/em>）&lt;/li>
&lt;li>Microsoft Word 等软件中具有断字功能，使用动态规划可以确定什么地方断字以确保行长一致。&lt;/li>
&lt;/ul></description></item><item><title>[Jenkins]Error:403 No valid crumb was included in the request</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-01-31-err-403-in-ci/</link><pubDate>Wed, 31 Jan 2018 12:27:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-01-31-err-403-in-ci/</guid><description>&lt;h1 id="错误备忘">错误备忘&lt;/h1>
&lt;p>配置 &lt;code>jenkins&lt;/code> 的时候，一直报这个错，是因为 &lt;code>jenkins&lt;/code> 默认安全设置里面开启了 &lt;code>防止款站点请求伪造&lt;/code>。&lt;/p></description></item><item><title>[Python]python如何方便的操作MySQL和Oracle数据库</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-01-30-how-to-connect-mysql-and-oracle/</link><pubDate>Tue, 30 Jan 2018 01:27:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-01-30-how-to-connect-mysql-and-oracle/</guid><description>&lt;h1 id="环境">环境&lt;/h1>
&lt;ul>
&lt;li>python3 &lt;a href="https://www.python.org/downloads/release/python-364/">官方网站下载&lt;/a>&lt;/li>
&lt;li>pymysql &lt;code>pip3 install pymysql&lt;/code>&lt;/li>
&lt;li>cx_Oracle &lt;code>pip3 install cx-Oracle&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>[区块链]区块链和通证的应用与技术路径</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-01-21-blockchain-and-token/</link><pubDate>Sun, 21 Jan 2018 22:37:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-01-21-blockchain-and-token/</guid><description>&lt;blockquote>
&lt;p>前言：1 月 21 日参加 CSDN 举办的区块链沙龙，以下是来自 CSDN 副总裁孟岩的 Slide 笔记。表达上使用了个人的理解，如果有哪里理解错误，还请在评论中指正。&lt;/p>
&lt;/blockquote>
&lt;h2 id="产业形势和发展方向">产业形势和发展方向&lt;/h2>
&lt;h3 id="三大派别">三大派别&lt;/h3>
&lt;p>目前国内的区块链产业形势分为 &lt;code>币&lt;/code>，&lt;code>证&lt;/code>，&lt;code>链&lt;/code>三个派别，这三个群体需要分开来评判看待。&lt;/p>
&lt;p>最为我们大众所熟知的一些企业，或者说是一些数字货币，大都属于&lt;code>币&lt;/code>圈公司。这一类公司可以用六个字总结：“只造势，不做事”。各种铺天盖地的宣传，为的是制造其发行的数字货币的影响力，而并没有实际的实体价值依托。&lt;/p>
&lt;p>因为我们大家日常接触或听到的大部分都是币圈的公司信息，所以常常会有人说：“区块链这个技术没有实际的落地应用，只是个噱头”。其实不然，国外其实有很多的公司在做着基于区块链技术的应用，只是因为这一类的公司不会去发行数字货币，也不发通证（通证的概念后面会提到），只是在借助区块链技术在做着一些实际的应用产品，所以往往不被人所了解。这一类的公司就属于&lt;code>链圈&lt;/code>公司范畴。链圈的公司会有很多基于区块链技术的落地应用，但是因为每个产品都是独立的，影响力是很有限的，所以无法对全球产生&lt;code>革命&lt;/code>性的改变。&lt;/p>
&lt;p>还有第三个派别就是&amp;mdash;“通证派”。首先理解一下通证的定义，通证，英文的名字是&lt;code>Token&lt;/code>，还有的人译作“代币”，但是这个真不是一个很雅的翻译，我更倾向于称之为“通证”。通证的核心是&lt;code>通&lt;/code>，流通，通证是一种价值转移的载体形式。&lt;/p>
&lt;p>通证有广义的通证和狭义的通证之分，狭义的通证包含但不限于：身份证，房产证，信用卡，用户积分，通行证，门票，购物卡，发票，股票，债券等等&amp;hellip;广义的通证是在狭义的通证基础上多一个&lt;code>数字加密货币&lt;/code>。&lt;/p></description></item><item><title>[python]web框架中的代码自动重载怎么实现</title><link>http://www.vimiix.com/vimiix-blog/posts/2018-01-08-autoreload-code-in-python/</link><pubDate>Mon, 08 Jan 2018 22:37:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2018-01-08-autoreload-code-in-python/</guid><description>&lt;p>在开发和调试 wsgi 应用程序时，有很多方法可以自动重新加载代码。例如，如果你使用的是&lt;code>werkzeug&lt;/code>，则只需要传&lt;code>use_reloader&lt;/code>参数即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>run_sumple(&lt;span style="color:#e6db74">&amp;#39;127.0.0.1&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>, app, use_reloader&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 Flask,实际上在内部使用 werkzeug，所以你需要设置 debug = true：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>app&lt;span style="color:#f92672">.&lt;/span>run(debug&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>django 会在你修改任何代码的时候自动为你重新加载：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>python manage&lt;span style="color:#f92672">.&lt;/span>py runserver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有这些例子在本地开发的时候都非常有用，但是，建议不要在实际生产中使用。&lt;/p>
&lt;p>作为学习，可以一起来看一下，python 是如何让代码自动地重新加载的？&lt;/p></description></item><item><title>[python]ImportError:attempted relative import with no known parent package</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-12-29-import-error-relative-no-parent/</link><pubDate>Fri, 29 Dec 2017 12:37:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-12-29-import-error-relative-no-parent/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>在这篇文章中，我将会解析 &lt;code>ImportError: attempted relative import with no known parent package&lt;/code> 这个异常的原因。当你在运行的 python 脚本。使用了相对引用方式 &lt;em>(类似&lt;code>import ..module&lt;/code>)&lt;/em> 去引用包时，可能会出现这个异常。&lt;/p></description></item><item><title>[译]关于python字典类型最疯狂的表达方式</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-12-28-python-mystery-dict-expression/</link><pubDate>Thu, 28 Dec 2017 10:31:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-12-28-python-mystery-dict-expression/</guid><description>&lt;p>&lt;a href="https://juejin.im/post/5a4459b05188257d6a7ed76b">
&lt;figure>
&lt;img src="https://badge.juejin.im/entry/5a4459c9f265da43112080ea/likes.svg?style=flat-square" alt="" />
&lt;/figure>
&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>一篇来自 &lt;a href="https://dbader.org/blog/python-mystery-dict-expression">Dan Bader&lt;/a> 的有趣的博文，一起来学习一下，如何去研究一个意外的 Python 现象。&lt;/p>
&lt;/blockquote></description></item><item><title>写Flask应用时的一些优雅技巧</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-12-18-some-useful-tricks-in-flask/</link><pubDate>Mon, 18 Dec 2017 18:56:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-12-18-some-useful-tricks-in-flask/</guid><description>&lt;h2 id="借助find_modulesimport_string优雅地注册蓝图模块">借助&lt;code>find_modules&lt;/code>,&lt;code>import_string&lt;/code>优雅地注册蓝图模块&lt;/h2>
&lt;p>&lt;a href="http://werkzeug.pocoo.org/docs/0.13/utils/#werkzeug.utils.find_modules">&lt;code>find_modules&lt;/code>&lt;/a>, &lt;a href="http://werkzeug.pocoo.org/docs/0.13/utils/#werkzeug.utils.import_string">&lt;code>import_string&lt;/code>&lt;/a>这两个函数包含在&lt;code>werkzeug.utils&lt;/code>工具包中，借助着两个工具函数可以帮助我们在更优雅的给应用注册&lt;code>blueprint&lt;/code>模块，尤其是当项目中&lt;code>blueprint&lt;/code>模块很多的时候，会节省很多行代码，看起来更加的舒服。&lt;/p></description></item><item><title>[译]python中的global和nonlocal的实践</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-12-14-global-and-nonlocal-variable-in-python/</link><pubDate>Thu, 14 Dec 2017 18:51:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-12-14-global-and-nonlocal-variable-in-python/</guid><description>&lt;blockquote>
&lt;p>今天的博文翻译是关于 python 中 global 和 nonlocal 两个关键字的用法，原文的作者是来自孟加拉国的&lt;a href="https://twitter.com/subeen">Tamim Shahriar&lt;/a>，他的&lt;a href="http://love-python.blogspot.com.br/?view=classic">博客&lt;/a>非常适合新手朋友去阅读，都是简短而有意义的 python 实践。&lt;/p>
&lt;/blockquote>
&lt;p>我们大多数人都对 Python 中的全局变量很熟悉了。如果我们在一个模块中声明全局变量，模块内部的任何函数都可以访问这个全局变量。（模块可以理解为一个&lt;code>python&lt;/code>文件或&lt;code>.py&lt;/code>文件）&lt;/p></description></item><item><title>[译]Python的enumerate()函数揭秘</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-12-13-pythons-enumerate-function-demystified/</link><pubDate>Wed, 13 Dec 2017 19:51:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-12-13-pythons-enumerate-function-demystified/</guid><description>&lt;blockquote>
&lt;p>今天的原文的作者是来自国外的一位 Python“布道师”&lt;a href="https://dbader.org">Dan Bader&lt;/a>，他的博客完全就是一个个人品牌的学校。有跟多 Python 技巧，有很多他录制的 Youtube 视频，国内的 Pythonista 们，不妨订阅一下他的每周邮件推送。&lt;a href="https://www.getdrip.com/forms/80014959/submissions/new">订阅链接&lt;/a>&lt;/p>
&lt;p>今天的译文是他博客中的一篇，点击&lt;a href="https://dbader.org/blog/python-enumerate">查看原文&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>如何以去写以及为什么你应该使用 Python 中的内置枚举函数来编写更干净更加 Pythonic 的循环语句？&lt;/p></description></item><item><title>[译]编码，编码，编码!提高编程技能的唯一途径</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-12-12-code-code-code/</link><pubDate>Tue, 12 Dec 2017 20:51:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-12-12-code-code-code/</guid><description>&lt;blockquote>
&lt;p>最近博客没什么更新。工作上新项目马上要开始了，我很清楚自己的技术积累很匮乏，需要学习的东西太多了，但又不知该从何学起。以前听过一句话，不知道怎么规划学习的时候，只管学就好了。最近家里也储备了一批的新书，都还没来得及看，所以暂时不想怎么规划博客了，接下来到过年的这两个月，博客的文章将都是国外博客的译文，希望可以学习大神经验的同时提升自己的英文水平。&lt;/p>
&lt;p>今天是第一篇，来自前美国宇航局工程师，python 大神&lt;a href="https://github.com/pydanny">Daniel Roy Greenfeld&lt;/a>的博客中的一篇&lt;a href="https://www.pydanny.com/code-code-code.html">《code,code,code》&lt;/a>,旨在帮助新手程序员知道如何才能提高自己的编程技能。&lt;/p>
&lt;/blockquote></description></item><item><title>脱离Flask上下文，使用jinja2渲染html模板</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-11-15-use-jinjia2-without-flask/</link><pubDate>Wed, 15 Nov 2017 00:59:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-11-15-use-jinjia2-without-flask/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>首先，如果一个正常的 flask 带路由的接口，我们是不需要关心上下文对象的，Flask 做了很多“魔术”的方法，当一个 Flask 应用接收到一个请求的时候，它会在将逻辑委托给你的视图函数之前，创建好一个上下文对象。&lt;/p>
&lt;p>当我们返回的时候调用&lt;code>render_template(template, **context)&lt;/code>，就可以正常的渲染界面返回，在这个函数中，如果看一下源码就会发现，返回渲染之前，会创建一个 ctx 去获得当前环境的&lt;code>app&lt;/code>变量。然后通过这个 ctx 去渲染传进来的&lt;code>context&lt;/code>参数列表。&lt;/p></description></item><item><title>[译]Python3:变量注释</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-11-02-python3-variable-annotation/</link><pubDate>Thu, 02 Nov 2017 13:12:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-11-02-python3-variable-annotation/</guid><description>&lt;p>Python 在 3.6 版中添加了一个叫做&lt;strong>变量注释&lt;/strong>的语法。变量注释简单讲就是对于类型提示的增强，这个概念是在 Python3.5 中开始引入的。变量注释的完整解释在&lt;a href="https://www.python.org/dev/peps/pep-0526">PEP 526&lt;/a>中进行了详细说明。在本文中，我们将将要的回顾一下类型提示，然后再介绍新的变量注释语法。&lt;/p></description></item><item><title>rsync服务器配置文件参数备忘</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-10-30-rsync-params/</link><pubDate>Mon, 30 Oct 2017 13:12:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-10-30-rsync-params/</guid><description>最近工作中用到了 rsync 服务器，对于 rsync 服务器的配置来说，不是很复杂，网上有很多介绍。rsync 的配置文件是最重要的一部分。有很多参数需要了解一下，所以今天记录整理一下，方便以后自己查看。
基本介绍 Rsync（remote synchronize）是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件。Rsync 使用所谓的“Rsync 算法”来使本地和远 程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。
rsync 的配置文件是由一个或多个模块结构组成。一个模块定义是以方括弧中的模块名开始，直到下一个模块定义开始或者文件结束。
模块中包含格式为name = value的参数定义。每个模块其实就对应需要备份的一个目录树，比方说在实际环境中，有三个目录树需要备份：/www/、/home/web_user1/和/home/web_user2/，那么就需要在配置文件中定义三个模块，分别对应三个目录树。
配置文件是行为单位的，也就是说每个新行都表示一个新的注释、模块定义或者参数赋值。以#开始的行表示注释，以&amp;quot;&amp;ldquo;结束的行表示下面一行是该行的继续。参数赋值中等号后可能是一个大小写不敏感的字符串、一个以trure/false或者yes/no表示的布尔值。
全局参数 在文件中[modlue]之前的所有参数都是全局参数，当然也可以在全局参数部分定义模块参数，这时候该参数的值就是所有模块的默认值。
motd file 指定一个消息文件，当客户连接服务器时该文件的内容显示给客户，默认是没有 motd 文件的。该文件有无都不影响 rsync 的正常使用。
log file 指定 rsync 的日志文件，而不将日志发送给syslog。
pid file 指定 rsync 的 pid 文件。
syslog facility 指定 rsync 发送日志消息给 syslog 时的消息级别，常见的消息级别是：uth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, sys-log, user, uucp, local0, local1, local2, local3,local4, local5, local6和local7。
默认值是daemon。
模块参数 在全局参数之后就需要定义一个或多个模块了，模块中可以定义以下参数：
comment 给模块指定一个描述，该描述连同模块名在客户连接得到模块列表时显示给客户。默认没有描述定义。</description></item><item><title>自动化DDL审核|pymysql链接Inception中踩过的几个坑</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-09-28-problems-when-pymysql-connect-inception/</link><pubDate>Thu, 28 Sep 2017 19:12:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-09-28-problems-when-pymysql-connect-inception/</guid><description>&lt;p>简单整理了一下这几天使用 pymysql 链接 inception 做 sql 审核过程中出现的坑和解决方法。&lt;/p>
&lt;p>这些解决方法一定不是最漂亮的，如果有伙伴遇到同样的问题，并且有好的解决方案，请一定在留言中回一下我哦。&lt;/p>
&lt;p>先行感激！！&lt;/p></description></item><item><title>Python|寻找最大最小的N个元素几种方法</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-09-15-find-largest-or-smallest-number/</link><pubDate>Fri, 15 Sep 2017 09:48:44 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-09-15-find-largest-or-smallest-number/</guid><description>&lt;p>实际的生产中，常常会需要处理一个序列，找出其中的 N 个最大或者最小的元素，这里提供几种思路，不同的情况，使用不同的搜索方式，可以更好提高我们代码的运行效率。&lt;/p></description></item><item><title>Linux|CentOS系统yum安装pip及遇到的问题解决方法</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-08-27-pip-setup-and-solve-problems/</link><pubDate>Sun, 27 Aug 2017 14:16:25 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-08-27-pip-setup-and-solve-problems/</guid><description>&lt;p>&lt;strong>pip 是一个以 Python 计算机程序语言写成的软件包管理系统，他可以安装和管理软件包，另外不少的软件包也可以在“Python 软件包索引”（英语：Python Package Index，简称 PyPI）中找到。&lt;/strong>&lt;/p></description></item><item><title>Python|元组拆包和具名元组解析</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-08-05-tuple-unpacking/</link><pubDate>Sat, 05 Aug 2017 17:02:29 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-08-05-tuple-unpacking/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>在 Python 中元组是一个相较于其他语言比较特别的一个内置序列类型。有些 python 入门教程把元组成为“不可变的列表”，这种说法是不完备的，其并没有完整的概括元组的特点。除了用作不可变的列表，它还可以用于没有字段名的数据记录。下面的内容就围绕元组作为数据记录属性展开，并介绍带字段名的具名元组函数&lt;code>namedtuple&lt;/code>，列表属性不再本文中叙述。&lt;/p></description></item><item><title>[算法笔记]用递归和迭代的思想分别实现插入排序和选择排序</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-08-02-insert-sort-and-select-sort/</link><pubDate>Wed, 02 Aug 2017 17:17:25 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-08-02-insert-sort-and-select-sort/</guid><description>&lt;h1 id="思路">思路&lt;/h1>
&lt;!-- raw HTML omitted -->
&lt;h3 id="插入排序insert-sort">插入排序（insert sort）&lt;/h3>
&lt;blockquote>
&lt;p>先归纳性的假设前 n-1 个元素已经完成排序了，现在要将第 n 个元素&lt;!-- raw HTML omitted -->向前插入&lt;!-- raw HTML omitted -->到正确的位置上。这种方式称之为&lt;strong>插入排序法&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h3 id="选择排序selection-sort">选择排序（selection sort）&lt;/h3>
&lt;blockquote>
&lt;p>先找到整个序列中最大的元素，并将其&lt;!-- raw HTML omitted -->向后放&lt;!-- raw HTML omitted -->在 n（待排序的序列末尾）的位置上，然后继续递归排序剩下的元素。这种方式称之为&lt;strong>选择排序法&lt;/strong>&lt;/p>
&lt;/blockquote></description></item><item><title>[算法笔记]使用L形砖拼接国际象棋棋盘</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-08-01-cover-board-game/</link><pubDate>Tue, 01 Aug 2017 19:54:21 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-08-01-cover-board-game/</guid><description>&lt;h2 id="递归解决棋盘拼接问题">递归解决棋盘拼接问题&lt;/h2>
&lt;h3 id="题目介绍">题目介绍&lt;/h3>
&lt;p>如图所示，图中有一块角上缺了一个方格的国际象棋棋盘，现在我们想用 L 形砖拼接出这样一块棋盘。&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/chess-board.jpg" alt="" />
&lt;/figure>
&lt;/p></description></item><item><title>[算法笔记]侏儒排序算法实现和复杂度分析</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-07-31-gnomesort/</link><pubDate>Mon, 31 Jul 2017 15:58:21 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-07-31-gnomesort/</guid><description>&lt;h1 id="侏儒排序">侏儒排序&lt;/h1>
&lt;h3 id="介绍">介绍&lt;/h3>
&lt;p>侏儒排序是由 Hamid Sarbazi-Azad 在 2000 年提出的，也叫愚人排序法（Stupid sort）。这种排序算法一种简单的复杂度为&lt;code>平方级&lt;/code>的排序算法，一般实际生产中不会用到。&lt;/p></description></item><item><title>vmx-manager:基于django框架开发的cmdb系统</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-07-18-vmx-manager-a-cmdb-system-base-on-django/</link><pubDate>Tue, 18 Jul 2017 22:58:21 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-07-18-vmx-manager-a-cmdb-system-base-on-django/</guid><description>&lt;h2 id="系统介绍">系统介绍&lt;/h2>
&lt;p>VMX-Manager 是一个基于 Django 框架开发的一款 CMDB 管理系统，目前处于 beta 版本，功能主要包含: 管理系统管理的客户主机列表， 动态显示客户机状态信息，远程指令操作指定客户机以及主机与客户机之间的文件传输。&lt;/p></description></item><item><title>Python|内建函数getattr()函数详解</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-07-10-introduce-getattr-function/</link><pubDate>Mon, 10 Jul 2017 12:08:03 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-07-10-introduce-getattr-function/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>昨天在&lt;a href="https://www.hackerrank.com">Hackerrank&lt;/a>上面练习 Python 题目的时候，题目要求从终端输入命令和参数，然后脚本获取到以后执行相应的操作（&lt;a href="https://www.hackerrank.com/challenges/py-set-discard-remove-pop">查看原题&lt;/a>），作为初级程序员，我第一思路想到的解法就是枚举（因为题目上面限制了就 3 条命令）。通过&lt;code>if ... elif...elif...&lt;/code>的分支语句就解决了。Hackerrank 有一个好处就是，每一个题目都有一个讨论区，在讨论区中往往会有超出本人能力范围的巧妙高级解法发表在里面。有个大牛在讨论区发表了自己的解法，其中就用到了 getattr 这个内建函数，这样代码的扩展性就极强了，不再局限于本题目的三条指令。下面就记录一下这个有趣的函数。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="http://t.cn/RKtqwu4">上述代码查看传送门&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>DevOps|SaltStack的部署和基本指令</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-06-27-saltstack-setup-and-simple-cmds/</link><pubDate>Tue, 27 Jun 2017 20:08:03 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-06-27-saltstack-setup-and-simple-cmds/</guid><description>&lt;p>SaltStack 是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，。SaltStack 基于 Python 语言实现，结合轻量级消息队列（ZeroMQ）与 python 第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack 和 PyYAML 等）构建。&lt;/p></description></item><item><title>Web|关于cookie和session一点知识</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-06-22-cookie-and-session/</link><pubDate>Thu, 22 Jun 2017 16:03:54 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-06-22-cookie-and-session/</guid><description>&lt;h3 id="cookie维基百科定义httpszhwikipediaorgwikicookie">cookie(&lt;a href="https://zh.wikipedia.org/wiki/Cookie">维基百科定义&lt;/a>)&lt;/h3>
&lt;blockquote>
&lt;p>Cookie（复数形态 Cookies），中文名称为“小型文本文件”或“小甜饼”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。&lt;/p>
&lt;/blockquote></description></item><item><title>Python|使用Anaconda完成Python多环境配置</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-06-01-python-multiversion-dev-anaconda/</link><pubDate>Thu, 01 Jun 2017 09:53:54 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-06-01-python-multiversion-dev-anaconda/</guid><description>&lt;p>今天是六月一号，国际儿童节，首先祝生活中的每一个宝宝（&lt;em>只要你觉得自己是宝宝，那你就是&lt;/em>）&lt;!-- raw HTML omitted -->Happy Children&amp;rsquo;s Day!!!&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>OK,言归正传，昨天开始学习 Django 开发，个人认为，作为主流趋势，我倾向于用 pyhton3.x 开发，因为 web 开发有别与其他，对于实时响应要求相对较高，python3 可以更好的优化。在刚刚结束的 Pycon2017 上，来自 Instagram 的 Lisa Guo 和 Hui Ding（两位华裔）分别介绍了&lt;a href="https://www.youtube.com/watch?v=66XoCk79kjM">Instagram 为何选择 py3 以及整个网站迁移 py3 的过程&lt;/a>。虽然还不是很具体了解其中的差别，但一个体量不小的公司做出了向 python3 迁移的举动，一定说明 python3 在 web 开发上有肯定的优势。&lt;/p></description></item><item><title>Python-from __future__ import print_function</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-05-12-print-function/</link><pubDate>Fri, 12 May 2017 14:55:03 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-05-12-print-function/</guid><description>&lt;p>Python 提供了**__future__**模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性&lt;/p>
&lt;p>在 python2.x 的环境是使用下面语句，则第二句语法检查通过，第三句语法检查失败&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Python" data-lang="Python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> __future__ &lt;span style="color:#f92672">import&lt;/span> print_function
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;good&amp;#39;&lt;/span>) &lt;span style="color:#75715e">#可以通过执行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print &lt;span style="color:#e6db74">&amp;#39;bad&amp;#39;&lt;/span> &lt;span style="color:#75715e">#语法错误&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[转]Python中eval的强大与潜在风险</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-05-04-how-to-use-eval/</link><pubDate>Thu, 04 May 2017 23:57:34 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-05-04-how-to-use-eval/</guid><description>这两天在做项目的过程中，遇到 eval 这个方法，不是很会用，经过一番搜索学习，特此收藏一篇乌云网深度好文，以备以后回顾。
原文出处：WooYun - 隐形人真忙
0x00 前言 eval 是 Python 用于执行 python 表达式的一个内置函数，使用 eval，可以很方便的将字符串动态执行。比如下列代码：
#!python &amp;gt;&amp;gt;&amp;gt; eval(&amp;#34;1+2&amp;#34;) 3 &amp;gt;&amp;gt;&amp;gt; eval(&amp;#34;[x for x in range(10)]&amp;#34;) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 当内存中的内置模块含有 os 的话，eval 同样可以做到命令执行：
#!python &amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; eval(&amp;#34;os.system(&amp;#39;whoami&amp;#39;)&amp;#34;) win-20140812chjadministrator 0 当然，eval 只能执行 Python 的表达式类型的代码，不能直接用它进行 import 操作，但 exec 可以。如果非要使用 eval 进行 import，则使用import：
#!python &amp;gt;&amp;gt;&amp;gt; exec(&amp;#39;import os&amp;#39;) &amp;gt;&amp;gt;&amp;gt; eval(&amp;#39;import os&amp;#39;) Traceback (most recent call last): File &amp;#34;&amp;#34;, line 1, in File &amp;#34;&amp;#34;, line 1 import os ^ SyntaxError: invalid syntax &amp;gt;&amp;gt;&amp;gt; eval(&amp;#34;__import__(&amp;#39;os&amp;#39;).</description></item><item><title>随笔|做一个比昨天的自己更优秀的人</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-04-26-better-than-yesterday/</link><pubDate>Wed, 26 Apr 2017 10:17:49 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-04-26-better-than-yesterday/</guid><description>正文 还依稀记得在上学时
不止一次的憧憬着自己毕业后
着一身西装白领，阔步在高楼林立之间
做着一些 change world 的事情
每每这个时候，是多么的盼望着赶快领到毕业证
然后走上人生巅峰
白驹过隙
此时的我仿佛还未长大
猛一回头
毕业后，三个年头的时光
已经被我踏平在了来的路上
不禁噗嗤一笑
心里却涌上一股暗淡的小情绪
“真的已经三年了吗”
为什么每天上下班依旧带着上下课的影子
租的房子不就是换了一个样子的宿舍吗
为什么和在上学相比，没有想象中那么大的变化
这就是工作的样子吗
没有西装白领
每天依旧是 T 恤牛仔裤
没有阔步高楼
每天穿梭于地铁人海
更没有做着 Change world 的事情
零零碎碎，嘻嘻哈哈是现在每天的生活基调
哪里出了问题了吗
心里有个声音在若隐若现
生活的精致还是粗糙
不是生活本身的属性
而是自己一分一秒经历出来的
你若报之以笑
它必还之以歌
笑着努力面对每一天
再回首，生活就是你想要的样子
不惆怅未来，做一个比昨天的自己更优秀的人</description></item><item><title>Python操作MySQL数据库</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-04-20-use-python-to-operate-mysql/</link><pubDate>Thu, 20 Apr 2017 23:57:34 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-04-20-use-python-to-operate-mysql/</guid><description>&lt;p>
&lt;figure>
&lt;img src="http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/python&amp;#43;mysql.jpg" alt="" />
&lt;/figure>
&lt;/p></description></item><item><title>Python-文件操作</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-04-13-file-operation/</link><pubDate>Thu, 13 Apr 2017 15:50:34 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-04-13-file-operation/</guid><description>&lt;p>
&lt;figure>
&lt;img src="https://static.vimiix.com/uPic/2021-04-06/uDCgf4.jpg" alt="header" />
&lt;/figure>
&lt;/p>
&lt;h2 id="打开文件">打开文件&lt;/h2>
&lt;p>在 Pyhton 中，使用&lt;!-- raw HTML omitted -->open()&lt;!-- raw HTML omitted -->函数打开文件，并返回文件对象，拿到这个文件对象，就可以读取或修改这个文件。&lt;!-- raw HTML omitted -->open()&lt;!-- raw HTML omitted -->是一个 python 内建函数，可以直接调用。&lt;/p></description></item><item><title>Python-关于Python中闭包的一些理解</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-04-09-about-closure/</link><pubDate>Sun, 09 Apr 2017 17:07:34 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-04-09-about-closure/</guid><description>&lt;p>
&lt;figure>
&lt;img src="https://static.vimiix.com/uPic/2021-04-06/rRo70V.jpg" alt="" />
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>看不懂的定义&lt;/strong>：闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)。&lt;/p></description></item><item><title>Python-高阶函数习题练习</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-04-08-practice-by-using-higher-order-functions/</link><pubDate>Sat, 08 Apr 2017 15:50:34 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-04-08-practice-by-using-higher-order-functions/</guid><description>&lt;p>
&lt;figure>
&lt;img src="http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/map-reduce-filter.jpg" alt="" />
&lt;/figure>
&lt;/p>
&lt;h5 id="本文是针对mapreduce和filter三个高阶函数的程序练习">本文是针对map()，reduce()和filter()三个高阶函数的程序练习。&lt;/h5></description></item><item><title>自助购物机交易源码</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-04-05-self-service-shopping-machine/</link><pubDate>Wed, 05 Apr 2017 18:57:34 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-04-05-self-service-shopping-machine/</guid><description>&lt;p>
&lt;figure>
&lt;img src="http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/self-service-machine.jpg" alt="" />
&lt;/figure>
&lt;/p>
&lt;h5 id="本文是一篇纯源码功能上实现了自助购物机的基本交易过程">本文是一篇纯源码，功能上实现了自助购物机的基本交易过程。&lt;/h5></description></item><item><title>Python-运算符和流程控制</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-04-01-operators-and-flow-control/</link><pubDate>Sat, 01 Apr 2017 14:34:20 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-04-01-operators-and-flow-control/</guid><description>&lt;p>
&lt;figure>
&lt;img src="http://vimiix-blog.oss-cn-qingdao.aliyuncs.com/operator-flow-control.jpg" alt="" />
&lt;/figure>
&lt;/p>
&lt;p>随手笔记，本篇介绍了python中的各种运算符以及2种流程控制语句。&lt;/p></description></item><item><title>Python|对于元组和字典的认识</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-03-31-introduction-of-tuple-and-dict/</link><pubDate>Fri, 31 Mar 2017 15:00:06 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-03-31-introduction-of-tuple-and-dict/</guid><description>&lt;p>本篇是一篇随手笔记，记录了对于 Python 的数据类型中元组（Tuple）和字典（Dict）的一些认识，以及部分内置方法的介绍。&lt;/p></description></item><item><title>Python|py2中字符与字节之间的编解码</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-03-28-encode-and-decode/</link><pubDate>Tue, 28 Mar 2017 13:56:18 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-03-28-encode-and-decode/</guid><description>&lt;p>据说，每个做 Python 开发的都被字符编码的问题搞晕过，最常见的错误就是 UnicodeEncodeError、UnicodeDecodeError，你好像知道怎么解决，遗憾的是，错误又出现在其它地方，问题总是重蹈覆辙，str 到 unicode 之间的转换用哪 decode 还是 encode 方法还特不好记，老是混淆，问题究竟出在哪里？&lt;/p></description></item><item><title>Python-SyntaxError:Non-ASCII character '\e8' in....</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-03-15-syntaxerror-non-ascii-character-e8-in/</link><pubDate>Wed, 15 Mar 2017 22:53:51 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-03-15-syntaxerror-non-ascii-character-e8-in/</guid><description>&lt;h2 id="syntaxerrornon-ascii-character-e8-in-file">SyntaxError:Non-ASCII character &amp;lsquo;\e8&amp;rsquo; in File&amp;hellip;&lt;/h2></description></item><item><title>Linux-软件包管理</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-03-13-rpm-and-yum/</link><pubDate>Mon, 13 Mar 2017 22:41:08 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-03-13-rpm-and-yum/</guid><description>&lt;h6 id="来一首歌当背景音乐">来一首歌当背景音乐&lt;/h6>
&lt;!-- raw HTML omitted --></description></item><item><title>Linux-rhel7.2操作系统安装</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-03-08-rhel7-2-os-setup/</link><pubDate>Wed, 08 Mar 2017 23:00:31 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-03-08-rhel7-2-os-setup/</guid><description>RHEL7 红帽公司发布的企业 Linux7 版本。
RHEL6 与 RHEL7 的关键区别： 显著提升 Docker 的兼容性 （Docker 容器级虚拟化技术）
默认文件系统从 EXT4 改为 XFS
系统管理的进一步简化
新版本内核 3.10 提供更多文件系统的支持
RHEL7 的安装 启动画面
界面说明：
** Install Red Hat Enterprise Linux 7.2 ** #安装 RHEL 7.2
** Test this media &amp;amp; install Red Hat Enterprise Linux 7.2** #测试安装文件并安装 RHEL 7.2
** Troubleshooting** #修复故障
一般选择第一项就可以了
注：在 Trobleshooting 模式下，界面如下：
界面说明：
Install Red Hat Enterprise Linux 7.2 in basic graphics mod #基本图形化安装
Rescue a Red Hat Enterprise Linux system #修复系统</description></item><item><title>Linux-git branch用法(查看、新建、删除、重命名)</title><link>http://www.vimiix.com/vimiix-blog/posts/2017-03-08-git-branch-usage/</link><pubDate>Wed, 08 Mar 2017 10:41:08 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2017-03-08-git-branch-usage/</guid><description>&lt;p>
&lt;figure>
&lt;img src="https://static.vimiix.com/uPic/2021-04-06/KQLlUb.jpg" alt="" />
&lt;/figure>
&lt;/p></description></item></channel></rss>