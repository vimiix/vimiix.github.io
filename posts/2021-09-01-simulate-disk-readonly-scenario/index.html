<!doctype html><html lang=cn-zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>磁盘只读（readonly）故障场景模拟</title><meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1>磁盘只读（readonly）故障场景模拟</h1><b><time>2021.09.01 16:15</time></b>
<a href=/%20/tags/disk>disk</a>
<a href=/%20/tags/simulate>simulate</a>
<a href=/%20/tags/test>test</a><div><p>假设服务器目前有多个盘，<code>vdb1</code>这块分区盘专门用于数据库程序的数据目录，我们就用 <code>vdb1</code> 这个盘来模拟只读故障场景。</p><p><figure><img src=https://static.vimiix.com/upic/2021-09-01/image-20210901154323971.png alt=image-20210901154323971></figure></p><h3 id=1-卸载指定盘>1. 卸载指定盘</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>umount /dev/vdb1
</code></pre></div><p>想要如期卸载掉，需要确保该盘上没有被正在运行进程依赖，如果有运行中的进程依赖这个盘，会报如下报 <code>target is busy</code> 的错误：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>umount: /opt: target is busy.
</code></pre></div><p>遇到该错误时，可以通过<code>lsof [mountpoint]</code> 命令来查看有哪些进程依赖这块盘，kill 掉相应的进程后重新卸载。</p><h3 id=2-配置伪设备来镜像-devvdb1-的内容>2. 配置伪设备来镜像 /dev/vdb1 的内容</h3><p>卸载成功后，我们通过 <code>losetup</code> 指令来配置一个loop设备（<em>在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件</em>）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>losetup /dev/loop0 /dev/vdb1
</code></pre></div><p>执行指令后，可以通过 <code>losetup -l</code> 查看当前服务器上的 loop 设备列表：</p><p><figure><img src=https://static.vimiix.com/upic/2021-09-01/image-20210901155336595.png alt=image-20210901155336595></figure></p><h3 id=3-挂载-devloop0>3. 挂载 /dev/loop0</h3><p>我们已经有一个 <code>/dev/loop0</code> 的伪设备镜像到了 <code>/dev/vdb1</code> 上，此时，我们来挂载 <code>/dev/loop0</code> 这个伪设备：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mount /dev/loop0 /opt -o rw,errors<span style=color:#f92672>=</span>remount-ro
</code></pre></div><p>通过 <code>df -h</code> 可以查看到 <code>/dev/loop0</code> 已经正常挂载上了</p><p><figure><img src=https://static.vimiix.com/upic/2021-09-01/image-20210901160108398.png alt=image-20210901160108398></figure></p><h3 id=4-正常启动应用进程这里测试用opengauss数据库>4. 正常启动应用进程（这里测试用opengauss数据库）</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>gs_ctl start -D /opt/mogdb/data/
</code></pre></div><h3 id=5-修改磁盘为只读模式故障注入>5. 修改磁盘为只读模式（故障注入）</h3><p><code>blockdev</code> 命令行工具是用于控制区块设备程序</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>blockdev --setro /dev/vdb1
</code></pre></div><p>此时，尝试写入 <code>/dev/loop0</code> 设备，将导致I/O错误。一旦文件系统驱动程序检测到，它将以只读方式重新挂载文件系统。</p><p>这样就实现了磁盘只读故障的场景模拟。</p><h3 id=6-测试后恢复系统>6. 测试后恢复系统</h3><p>a. 取消挂载</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>umount /opt
</code></pre></div><p>b. 删除伪设备</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>losetup -d /dev/loop0
</code></pre></div><p>c. 将 <code>/dev/vdb1</code> 设备恢复为可读写</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>blockdev --setrw /dev/vdb1
</code></pre></div><p>d. 将 <code>/dev/vdb1</code> 重新挂载回来</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mount /dev/vdb1 /opt
</code></pre></div><p>&mdash; EOF &mdash;</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/2021-09-01-simulate-disk-readonly-scenario/>磁盘只读（readonly）故障场景模拟</a></li><li><a href=/posts/2021-07-08-opengauss-driver-and-orm/>使用SQLAlchemy以多IP方式连接openGauss数据库</a></li><li><a href=/posts/2021-04-07-concurrency-in-go/>Golang的并行模式实践</a></li><li><a href=/posts/2021-03-22-auth-windows-user-in-golang/>Golang实现Windows系统用户和密码校验</a></li><li><a href=/posts/2020-03-11-beanstalkd-note/>beanstalkd消息队列</a></li></ul></div></div></aside><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://www.vimiix.com/posts/2021-09-01-simulate-disk-readonly-scenario/",this.page.identifier="/posts/2021-09-01-simulate-disk-readonly-scenario/"};(function(){var a=document,b=a.createElement('script');b.src='https://vimiix-blog.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2021
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>