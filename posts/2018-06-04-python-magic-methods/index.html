<!doctype html><html lang=cn-zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>[转]Python中的魔术方法汇总</title><meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1>[转]Python中的魔术方法汇总</h1><b><time>2018.06.04 13:20</time></b>
<a href=/%20/tags/magic-method>magic method</a>
<a href=/%20/tags/python>Python</a><div><blockquote><p>这是一篇很不错的总结文章，简单易理解，洒家忍不住要转载收藏一下。</p><p>源文链接：<a href="http://algo.site/?cat=60">http://algo.site/?cat=60</a></p></blockquote><h3 id=基础>基础:</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>初始化一个实例</td><td><code>x = MyClass()</code></td><td><code>x.__init__()</code></td></tr><tr><td>作为一个字符串的"官方"表示</td><td><code>repr(x)</code></td><td><code>x.__repr__()</code></td></tr><tr><td>作为一个字符串</td><td><code>str(x)</code></td><td><code>x.__str__()</code></td></tr><tr><td>作为字节数组</td><td><code>bytes(x)</code></td><td><code>x.__bytes__()</code></td></tr><tr><td>作为格式化字符串</td><td><code>format(x, format_spec)</code></td><td><code>x.__format__(format_spec)</code></td></tr></tbody></table><ul><li><code>__init__()</code>方法在创建实例后调用.如果你想控制创建过程,请使用<code>__new__()</code>方法</li><li>按照惯例, <code>__repr__()</code> 应该返回一个有效的 Python 表达式的字符串</li><li><code>__str__()</code>方法也被称为你的<code>print(x)</code></li></ul><h3 id=迭代相关>迭代相关</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>遍历一个序列</td><td><code>iter(seq)</code></td><td><code>seq.__iter__()</code></td></tr><tr><td>从迭代器中获取下一个值</td><td><code>next(seq)</code></td><td><code>seq.__next__()</code></td></tr><tr><td>以相反的顺序创建一个迭代器</td><td><code>reversed(seq)</code></td><td><code>seq.__reversed__()</code></td></tr></tbody></table><ul><li><code>__iter__()</code>无论何时创建新的迭代器,都会调用该方法.</li><li><code>__next__()</code>每当你从迭代器中检索一下个值的时候,都会调用该方法</li><li><code>__reversed__()</code>方法并不常见.它需要一个现有序列并返回一个迭代器,该序列是倒序的顺序.</li></ul><h3 id=属性>属性</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>得到一个属性</td><td><code>x.my_property</code></td><td><code>x.__getattribute__('my_property')</code></td></tr><tr><td>获得一个属性</td><td><code>x.my_property</code></td><td><code>x.__getattr__('my_property')</code></td></tr><tr><td>设置一个属性</td><td><code>x.my_property = value</code></td><td><code>x.__setattr__('my_property', value)</code></td></tr><tr><td>阐述一个属性</td><td><code>del x.my_property</code></td><td><code>x.__delattr__('my_property')</code></td></tr><tr><td>列出所有属性和方法</td><td><code>dir(x)</code></td><td><code>x.__dir__()</code></td></tr></tbody></table><ul><li>如果你的类定义了一个<code>__getattribute__()</code>方法,Python 将在每次引用任何属性或方法名时调用它.</li><li>如果你的类定义了一个<code>__getattr__()</code>方法,Python 只会在所有普通地方查找属性后调用它.如果一个实例<code>x</code>定义了一个属性 <code>color</code>, <code>x.color</code>将不会调用<code>x.__getattr__('color')</code>; 它将简单地返回已经定义的<code>x.color</code>值.</li><li><code>__setattr__()</code>只要你为属性指定值,就会调用该方法.</li><li><code>__delattr__()</code>只要删除属性,就会调用该方法.</li><li><code>__dir__()</code>如果您定义一个<code>__getattr__()</code> 或者 <code>__getattribute__()</code> 方法,该方法很有用.通常情况下,调用<code>dir(x)</code>只会列出常规属性和方法.</li></ul><p>*<strong>*getattr</strong>()和<strong>getattribute</strong>()方法之间的区别很微妙但很重要.**</p><h3 id=函数类>函数类</h3><p>通过定义<strong>call</strong>()方法,您可以创建一个可调用类的实例 – 就像函数可调用一样.</p><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>来"调用"像函数一样的实例</td><td><code>my_instance()</code></td><td><code>my_instance.__call__()</code></td></tr></tbody></table><h3 id=行为>行为</h3><p>如果你的类作为一组值的容器 – 也就是说,如果问你的类是否"包含"一个值是有意义的 – 那么它应该定义下面的特殊方法,使它像一个集合一样.</p><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>序列的数量</td><td><code>len(s)</code></td><td><code>s.__len__()</code></td></tr><tr><td>否包含特定的值</td><td><code>x in s</code></td><td><code>s.__contains__(s)</code></td></tr></tbody></table><h3 id=字典映射>字典(映射)</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>通过它的 key 来获得值</td><td><code>x[key]</code></td><td><code>x.__getitem__(key)</code></td></tr><tr><td>通过它的 key 来设置一个值</td><td><code>x[key] = value</code></td><td><code>x.__setitem__(key, value)</code></td></tr><tr><td>删除键值对</td><td><code>del x[key]</code></td><td><code>x.__delitem__(key)</code></td></tr><tr><td>为丢失的 key 提供默认值</td><td><code>x[nonexistent_key]</code></td><td><code>x.__missing__(nonexistent_key)</code></td></tr></tbody></table><h3 id=数字>数字</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>加</td><td><code>x + y</code></td><td><code>x.__add__(y)</code></td></tr><tr><td>减</td><td><code>x - y</code></td><td><code>x.__sub__(y)</code></td></tr><tr><td>乘</td><td><code>x * y</code></td><td><code>x.__mul__(y)</code></td></tr><tr><td>整除</td><td><code>x / y</code></td><td><code>x.__trueiv__(y)</code></td></tr><tr><td>除</td><td><code>x // y</code></td><td><code>x.__floordiv__(v)</code></td></tr><tr><td>取余</td><td><code>x % y</code></td><td><code>x.__mod__(y)</code></td></tr><tr><td>整除与取余</td><td><code>divmod(x, y)</code></td><td><code>x.__divmod__(y)</code></td></tr><tr><td>平方</td><td><code>x ** y</code></td><td><code>x.__pow__(y)</code></td></tr><tr><td>左移</td><td><code>x &lt;&lt; y</code></td><td><code>x.__lshift__(y)</code></td></tr><tr><td>友移</td><td><code>x >> y</code></td><td><code>x.__rshift__(y)</code></td></tr><tr><td>按位 and 运算</td><td><code>x & y</code></td><td><code>x.__and__(y)</code></td></tr><tr><td>按位 xor 或运算</td><td><code>x ^ y</code></td><td><code>x.__xor__(y)</code></td></tr><tr><td>按位 or 运算</td><td>`x</td><td>y`</td></tr></tbody></table><p>上述一组特殊方法采用第一种方法:给定<code>x / y</code>,它们提供了一种方法让<code>x</code>说"我知道如何用<code>y</code>整除自己".以下一组特殊方法解决了第二种方法:它们为 y 提供了一种方法来说"我知道如何成为分母,并将自己整除 x".</p><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>加</td><td><code>x + y</code></td><td><code>x.__radd__(y)</code></td></tr><tr><td>减</td><td><code>x - y</code></td><td><code>x.__rsub__(y)</code></td></tr><tr><td>乘</td><td><code>x * y</code></td><td><code>x.__rmul__(y)</code></td></tr><tr><td>整除</td><td><code>x / y</code></td><td><code>x.__rtrueiv__(y)</code></td></tr><tr><td>除</td><td><code>x // y</code></td><td><code>x.__rfloordiv__(v)</code></td></tr><tr><td>取余</td><td><code>x % y</code></td><td><code>x.__rmod__(y)</code></td></tr><tr><td>整除与取余</td><td><code>divmod(x, y)</code></td><td><code>x.__rdivmod__(y)</code></td></tr><tr><td>平方</td><td><code>x ** y</code></td><td><code>x.__rpow__(y)</code></td></tr><tr><td>左移</td><td><code>x &lt;&lt; y</code></td><td><code>x.__rlshift__(y)</code></td></tr><tr><td>友移</td><td><code>x >> y</code></td><td><code>x.__rrshift__(y)</code></td></tr><tr><td>按位 and 运算</td><td><code>x & y</code></td><td><code>x.__rand__(y)</code></td></tr><tr><td>按位 xor 或运算</td><td><code>x ^ y</code></td><td><code>x.__rxor__(y)</code></td></tr><tr><td>按位 or 运算</td><td>`x</td><td>y`</td></tr></tbody></table><p>可是等等！还有更多！如果你正在进行"就地"操作,如<code>x /= 3</code>则可以定义更多特殊的方法.</p><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>加</td><td><code>x + y</code></td><td><code>x.__iadd__(y)</code></td></tr><tr><td>减</td><td><code>x - y</code></td><td><code>x.__isub__(y)</code></td></tr><tr><td>乘</td><td><code>x * y</code></td><td><code>x.__imul__(y)</code></td></tr><tr><td>整除</td><td><code>x / y</code></td><td><code>x.__itrueiv__(y)</code></td></tr><tr><td>除</td><td><code>x // y</code></td><td><code>x.__ifloordiv__(v)</code></td></tr><tr><td>取余</td><td><code>x % y</code></td><td><code>x.__imod__(y)</code></td></tr><tr><td>整除与取余</td><td><code>divmod(x, y)</code></td><td><code>x.__idivmod__(y)</code></td></tr><tr><td>平方</td><td><code>x ** y</code></td><td><code>x.__ipow__(y)</code></td></tr><tr><td>左移</td><td><code>x &lt;&lt; y</code></td><td><code>x.__ilshift__(y)</code></td></tr><tr><td>友移</td><td><code>x >> y</code></td><td><code>x.__irshift__(y)</code></td></tr><tr><td>按位 and 运算</td><td><code>x & y</code></td><td><code>x.__iand__(y)</code></td></tr><tr><td>按位 xor 或运算</td><td><code>x ^ y</code></td><td><code>x.__ixor__(y)</code></td></tr><tr><td>按位 or 运算</td><td>`x</td><td>y`</td></tr></tbody></table><p>还有一些"单个数"数学运算可以让你自己对类似数字的对象进行数学运算.</p><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>负数</td><td><code>-x</code></td><td><code>x.__neg__()</code></td></tr><tr><td>正数</td><td><code>+x</code></td><td><code>x.__pos__()</code></td></tr><tr><td>绝对值</td><td><code>abs(x)</code></td><td><code>x.__abs__()</code></td></tr><tr><td>逆</td><td><code>~x</code></td><td><code>x.__invert__()</code></td></tr><tr><td>复数</td><td><code>complex(x)</code></td><td><code>x.__complex__()</code></td></tr><tr><td>整数</td><td><code>int(x)</code></td><td><code>x.__int__()</code></td></tr><tr><td>浮点数</td><td><code>float(x)</code></td><td><code>x.__float__()</code></td></tr><tr><td>四舍五入到最近的整数</td><td><code>round(x)</code></td><td><code>x.__round__()</code></td></tr><tr><td>四舍五入到最近的 n 位数</td><td><code>round(x, n)</code></td><td><code>x.__round__(n)</code></td></tr><tr><td>最小整数</td><td><code>math.ceil(x)</code></td><td><code>x.__ceil__()</code></td></tr><tr><td>最大整数</td><td><code>math.floor(x)</code></td><td><code>x.__floor__()</code></td></tr><tr><td>截断 x 到 0 的最接近的整数</td><td><code>math.trunc(x)</code></td><td><code>x.__trunc__()</code></td></tr><tr><td>数字作为列表索引</td><td><code>a_list[x]</code></td><td><code>a_list[x.__index__()]</code></td></tr></tbody></table><h3 id=比较>比较</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>等于</td><td><code>x == y</code></td><td><code>x.__eq__(y)</code></td></tr><tr><td>不等于</td><td><code>x != y</code></td><td><code>x.__ne__(y)</code></td></tr><tr><td>小于</td><td><code>x &lt; y</code></td><td><code>x.__lt__(y)</code></td></tr><tr><td>小于等于</td><td><code>x &lt;= y</code></td><td><code>x.__le__(y)</code></td></tr><tr><td>大于</td><td><code>x > y</code></td><td><code>x.__gt__(y)</code></td></tr><tr><td>大于等于</td><td><code>x >= y</code></td><td><code>x.__ge__(y)</code></td></tr><tr><td>布尔</td><td><code>if x:</code></td><td><code>x.__bool__()</code></td></tr></tbody></table><h3 id=序列化>序列化</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>对象副本</td><td><code>copy.copy(x)</code></td><td><code>x.__copy__()</code></td></tr><tr><td>深拷贝</td><td><code>copy.deepcopy(x)</code></td><td><code>x.__deepcopy__()</code></td></tr><tr><td>序列化一个对象</td><td><code>pickle.dump(x, file)</code></td><td><code>x.__getstate__()</code></td></tr><tr><td>序列化一个对象</td><td><code>pickle.dump(x, file)</code></td><td><code>x.__reduce__()</code></td></tr><tr><td>序列化一个对象</td><td><code>pickle.dump(x, file, protocol_version)</code></td><td><code>x.__reduce_ex__(protocol_version)</code></td></tr><tr><td>取出恢复后的状态</td><td><code>x = pickle.load(fp)</code></td><td><code>x.__getnewargs__()</code></td></tr><tr><td>取出恢复后的状态</td><td><code>x = pickle.load(fp)</code></td><td><code>x.__setstate__()</code></td></tr></tbody></table><h3 id=with-语句>with 语句</h3><p>with 块限定了运行时上下文;在执行 with 语句时,&ldquo;进入"上下文,并在执行块中的最后一个语句后"退出"上下文.</p><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>进入 with 语句块</td><td><code>with x:</code></td><td><code>x.__enter__()</code></td></tr><tr><td>退出 with 语句块</td><td><code>with x:</code></td><td><code>x.__exit__(exc_type, exc_value, traceback)</code></td></tr></tbody></table><h2 id=真正深奥的东西>真正深奥的东西</h2><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>一个类的构造函数</td><td><code>x = MyClass()</code></td><td><code>x.__new__()</code></td></tr><tr><td>一个类的析构函数</td><td><code>del x</code></td><td><code>x.__del__()</code></td></tr><tr><td>只有一组特定的属性需要定义</td><td>“</td><td><code>x.__solts__()</code></td></tr><tr><td>hash 码</td><td><code>hash(x)</code></td><td><code>x.__hash__()</code></td></tr><tr><td>获得一个属性的值</td><td><code>x.color</code></td><td><code>type(x).__dict__['color'].__get__(x, type(x))</code></td></tr><tr><td>设置一个属性的值</td><td><code>x.color = 'PapayaWhip'</code></td><td><code>type(x).__dict__['color'].__set__(x, 'PapayaWhip')</code></td></tr><tr><td>删除一个属性</td><td><code>del x.color</code></td><td><code>type(x).__dict__['color'].__del__(x)</code></td></tr><tr><td>一个对象是否是你的一个类的实例</td><td><code>isinstance(x, MyClass)</code></td><td><code>MyClass.__instancecheck__(x)</code></td></tr><tr><td>一个类是否是你的类的子类</td><td><code>isinstance(C, MyClass)</code></td><td><code>MyClass.__subclasscheck__(C)</code></td></tr><tr><td>一个类是否是抽象基类的实例</td><td><code>isinstance(C, MyABC)</code></td><td><code>MyABC.__subclasshook__(C)</code></td></tr></tbody></table><p>Python 正确调用<code>__del__()</code>特殊方法时非常复杂.为了完全理解它,你需要知道 Python 如何跟踪内存中的对象.这里有一篇关于<a href=https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/>Python 垃圾收集和类析构函数的好文章</a>. (原文在墙外是一篇早期的英文文章，洒家顺手也给翻译了，请看<a href=https://vimiix.com/post/2018/06/04/python-destructor-and-garbage-collection-notes/>下一篇文章</a>)你还应该阅读关于<a href=https://docs.python.org/3/library/weakref.html>弱引用,weakref 模块</a>,以及可能的<a href=https://docs.python.org/3/library/gc.html>gc 模块</a>以获得更好的度量.</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/2021-12-21-learn-distributed-transaction/>分布式事务笔记(XA,TCC,Saga)</a></li><li><a href=/posts/2021-09-01-simulate-disk-readonly-scenario/>磁盘只读（readonly）故障场景模拟</a></li><li><a href=/posts/2021-07-08-opengauss-driver-and-orm/>使用SQLAlchemy以多IP方式连接openGauss数据库</a></li><li><a href=/posts/2021-04-07-concurrency-in-go/>Golang的并行模式实践</a></li><li><a href=/posts/2021-03-22-auth-windows-user-in-golang/>Golang实现Windows系统用户和密码校验</a></li></ul></div></div></aside><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://www.vimiix.com/posts/2018-06-04-python-magic-methods/",this.page.identifier="/posts/2018-06-04-python-magic-methods/"};(function(){var a=document,b=a.createElement('script');b.src='https://vimiix-blog.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2021
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>