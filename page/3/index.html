<!doctype html><html lang=cn-zh><head><meta name=generator content="Hugo 0.120.4"><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Hi, I'm Vimiix</title>
<meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title="Hi, I'm Vimiix"></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1><a href=https://www.vimiix.com/posts/2018-10-10-dont-just-learn-a-new-language-framework-implement-it-as-a-running-open-source-project/>[译]实践出真知</a></h1><b><time>2018.10.10 23:22</time></b>
<a href=/tags/note>note</a>
<a href=/tags/translation>translation</a><div><p>Aristotle（亚里士多德），希腊著名的哲学家和科学家，曾经说过：“对于那些我们在能做到之前必须学习如何做的事情，我们需要边做边学 (<em>For the things we have to learn before we can do them, we learn by doing them.</em>)”。想象一下，假如你已经读过 3 本关于骑行的书了，然后有人给你一辆自行车并让你骑它，你能骑吗？很显然，答案是“不能”。这无关乎你曾经读了多少关于骑行的书或你看了多少相关视频的事情。它需要你真正骑上一辆自行车，去保持平衡，去学习脚，手和眼睛的协调配合才能掌握的一件事情。学习新技术，新语言或框架同样也是如此。</p><p>如果现在你在想：我都不会某个语言或某个框架，我要怎么去实现这个开源项目呢，那么先停止抱怨。也许你是技术或编程的新手，但你需要知道如何去学习新事物。学习新东西的最好方法就是实践。这篇文章将重点关注普适通用的方法。它会帮助你从我想要学习&rsquo;X&rsquo;到我有一个项目在&rsquo;X&rsquo;运行，所以继续往下看。如果你决定通过做一个项目来学习新东西，那就把它开源吧。Github 是托管你的开源项目的首选服务商。在其上你可以享受很多的免费服务。这篇文章的编写主要面向编程起步者，但对于经验丰富的软件工程师也同样有用。</p><a href=https://www.vimiix.com/posts/2018-10-10-dont-just-learn-a-new-language-framework-implement-it-as-a-running-open-source-project/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-08-27-running-your-flask-application-over-https/>[译]通过HTTPS协议运行你的Flask程序</a></h1><b><time>2018.08.27 17:22</time></b>
<a href=/tags/https>HTTPS</a>
<a href=/tags/ssl>SSL</a>
<a href=/tags/flask>Flask</a>
<a href=/tags/translation>translation</a><div><p>我们在开发 Flask 应用程序时，通常通过运行 Flask 自带的 Web 服务器来开发测试，这个服务器提供了基本的但功能完备的 WSGI 服务器。但开发结束以后，在应用程序上线到生成环境时，有很多不得不考虑的事情，其中之一是我们是否应该要求客户端使用加密连接以增加安全性。</p><p>人们总是问我这个问题，特别是如何在 HTTPS 协议上部署 Flask 服务器。在本文中，我将介绍几种为 Flask 应用程序添加加密的方案，从一个非常简单的可以在五秒内实现，到一个强大的就像我的网站一样可以得到一个 A +评级解决方案（<a href="https://www.ssllabs.com/ssltest/analyze.html?d=blog.miguelgrinberg.com">我的网站的 SSL 分析数据</a>）。</p><a href=https://www.vimiix.com/posts/2018-08-27-running-your-flask-application-over-https/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-08-13-git-best-practice/>Git开发记录-合并多条commit最佳实践</a></h1><b><time>2018.08.13 19:22</time></b>
<a href=/tags/git>git</a><div><h2 id=问题>问题</h2><p>常规的多人基于 GIT 协作开发的时候，都是遵循先 fork 一份主版本代码到自己的账号下面，然后基于本账户的版本，开分支来开发功能或修 Bug，完成以后再讲修改的内容，提交一个完整的 PR 贡献回主版本。</p><p>在本分支上开发的过程中，有时候不得不先提交到自己账号下面的克隆版本中来测试（比如豆瓣的<code>dae pre</code>，无法在本地生成预览，需要提交到远端），我们不能保证一次性提交就做到完美，避免不了会往复的修改后提交，这样的一次次测试用的 commit 属于是冗余的琐碎信息，对于主版本迭代是没有价值的。如果直接在基于该分支提交 PR，甚至被<code>merge</code>到<code>upstream/master</code>主版本中，这些不必要的 commit 信息也会包含进主版本中。这当然不是一个理想的迭代方式。</p><p>现在问题明确以后，就是一个目标：<strong>将这些开发中的所有 commit 都合并为一条有意义的 commit 信息提交给主版本</strong>。</p><a href=https://www.vimiix.com/posts/2018-08-13-git-best-practice/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-07-26-channels2-tutorial/>Django Channels2.0 websocket最佳实践</a></h1><b><time>2018.07.26 02:56</time></b>
<a href=/tags/django>Django</a>
<a href=/tags/channels>Channels</a>
<a href=/tags/websocket>websocket</a><div><p>做 web 后端开发，少不了要和 websocket 打交道。之前写过一篇关于 websocket 的实践文章 &mdash; <a href=https://vimiix.com/post/2018/04/02/python-websocket/>《[python]记录关于 websocket 的原理和使用》</a> ，不过，从 GITHUB 上可以看到，<strong>django-websocket</strong> 这个开源项目俨然已经是一个被放弃了的坑，并且在使用的过程中确实也有很多坑，果断弃之。</p><p>今天想聊的就是目前业界大牛都在推荐的一个框架&ndash;<a href=https://github.com/django/channels>Channels</a>， Channels 是针对 Django 项目的一个增强框架，它可以是的同步的 Django 项目转变为异步的项目。它可以使得 Django 项目不仅支持 HTTP 请求，还可以支持 Websocket, chat 协议，IOT 协议 ，甚至是你自定义的协议，同时也整合了 Django 的 auth 以及 session 系統等等。</p><a href=https://www.vimiix.com/posts/2018-07-26-channels2-tutorial/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-07-17-learn-contextlib/>浅谈Python中的上下文管理</a></h1><b><time>2018.07.18 00:56</time></b>
<a href=/tags/python>Python</a>
<a href=/tags/context>context</a><div><h2 id=with-语法>with 语法</h2><p>平常在写 Python 代码的时候，经常会用到<code>with</code> 来处理一个上下文环境，比如文件的打开关闭，数据库的连接关闭等等。</p><p><code>with</code>语法的使用，需要我们处理的对象实现<code>__enter__</code>和<code>__exit__</code>两个魔术方法来支持。<code>__enter__</code>函数处理逻辑函数之前需要做的事情，并返回操作对象作为<code>as</code>后面的变量，<code>__exit__</code>函数处理当代码离开<code>with</code>代码块以后的事情。</p><p><code>with</code>语法非常方便的让我使用资源并且不用操心忘记后续操作所带来的隐患。</p><a href=https://www.vimiix.com/posts/2018-07-17-learn-contextlib/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-05-grokking-algorithms-chapter-7/>《算法图解》读书笔记7-狄克斯特拉算法</a></h1><b><time>2018.07.16 22:20</time></b>
<a href=/tags/algorithm>algorithm</a>
<a href=/tags/python>Python</a>
<a href=/tags/dijkstra>Dijkstra</a><div><h2 id=概念>概念</h2><blockquote><p>狄克斯特拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题 (该算法不能处理包含负边的图)。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p></blockquote><a href=https://www.vimiix.com/posts/2018-06-05-grokking-algorithms-chapter-7/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-07-02-wake-up-time/>跳槽</a></h1><b><time>2018.07.02 14:36</time></b>
<a href=/tags/%E7%94%9F%E6%B4%BB>生活</a>
<a href=/tags/%E8%B7%B3%E6%A7%BD>跳槽</a><div>不知不觉，一个月没有写东西。感觉很快，因为没有感觉；但又感觉很慢，因为心理一直在作斗争。
这将近一个月的时间里，我基本没有和圈内的朋友交流，自己都感觉自己像蒸发了一样。这一个月的经过，给我积累了人生的一次重要经验——项目一定要选对人。剩下的就留给时间去消化吧。
今天以后，我将继续恢复日常的上班，学习，记录生活。
今天，北京天气很好。趁着阳光正好，我正式入职豆瓣了。
豆瓣，因为喜欢 python，慕名而来。
希望自己未来可以在这个 python 的"伊甸园"里面茁壮地成长！</div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-04-python-destructor-and-garbage-collection-notes/>[译]python中垃圾回收和析构函数笔记</a></h1><b><time>2018.06.04 14:36</time></b>
<a href=/tags/gc>GC</a>
<a href=/tags/python>Python</a><div><blockquote><p>紧接上一篇转载的文章<a href=https://vimiix.com/post/2018/06/04/python-magic-methods/>《Python 魔术方法总结》</a>文末提及的英文参考文章，洒家顺手就翻译了一下。方便墙内的同学学习。这篇文章不仅指出了 Python 如何处理垃圾回收，还提到了我们作为程序员不应该只借助现代化 IDE 的函数提示功能去完成代码，应该多去看官方的完整文档，可以知道哪些函数被废弃的，哪些函数在使用时需要注意什么等等一些很重要的信息。话不多说，自己体会，请向下阅读文章吧。</p><p>原文链接：<a href=https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/>https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/</a></p></blockquote><p>我很少在 Python 对象中使用析构函数。我猜 Python 的动态特性往往弱化了对析构函数的需求。但是现在，假如我需要在对象被销毁时，或者更确切地说，当程序退出时，要将一些数据写入磁盘。这时我会使用<code>__del__</code> 魔术方法在主要操作的类对象中定义了一个析构函数。但是奇怪的是，这个析构函数自始至终都没有被调用到。不仅在程序退出时没有被调用到，而且我手动使用<code>del</code>删除时也不会被调用。由于这个程序是我前一段时间写的，所有稍微有点不是很熟悉了，这导致我怀疑是我程序中有一个大的 BUG 存在。</p><a href=https://www.vimiix.com/posts/2018-06-04-python-destructor-and-garbage-collection-notes/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-04-python-magic-methods/>[转]Python中的魔术方法汇总</a></h1><b><time>2018.06.04 13:20</time></b>
<a href=/tags/magic-method>magic method</a>
<a href=/tags/python>Python</a><div><blockquote><p>这是一篇很不错的总结文章，简单易理解，洒家忍不住要转载收藏一下。</p><p>源文链接：<a href="http://algo.site/?cat=60">http://algo.site/?cat=60</a></p></blockquote><h3 id=基础>基础:</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>初始化一个实例</td><td><code>x = MyClass()</code></td><td><code>x.__init__()</code></td></tr><tr><td>作为一个字符串的"官方"表示</td><td><code>repr(x)</code></td><td><code>x.__repr__()</code></td></tr><tr><td>作为一个字符串</td><td><code>str(x)</code></td><td><code>x.__str__()</code></td></tr><tr><td>作为字节数组</td><td><code>bytes(x)</code></td><td><code>x.__bytes__()</code></td></tr><tr><td>作为格式化字符串</td><td><code>format(x, format_spec)</code></td><td><code>x.__format__(format_spec)</code></td></tr></tbody></table><a href=https://www.vimiix.com/posts/2018-06-04-python-magic-methods/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-03-grokking-algorithms-chapter-6/>《算法图解》读书笔记6-图以及广度优先搜索</a></h1><b><time>2018.06.03 16:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><h2 id=什么是图>什么是图</h2><p>图模拟一组链接，图由顶点和边组成。一个顶点可能与众多顶点直接相连，这些顶点被称为<strong>邻居</strong>。</p><p>图通常表示为：<code>G(V,E)</code>，其中，<code>G</code>表示一个图，<code>V</code>是图中顶点的集合，<code>E</code>是图中边的集合。</p><h4 id=简单图>简单图</h4><p>在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则这样的图称之为简单图。</p><h4 id=无向图>无向图</h4><p>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。</p><p>无向边：若顶点 M 到顶点 N 的边没有方向，称这条边为无向边，用无序偶对(M,N)或(N,M)表示。</p><a href=https://www.vimiix.com/posts/2018-06-03-grokking-algorithms-chapter-6/>Read more...</a></div></article><div><a href=/page/2/>上一页</a>
3 of 9
<a href=/page/4/>下一页</a></div></main><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2024
Copyright (c) 2017-2024, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>