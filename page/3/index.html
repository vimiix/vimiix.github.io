<!doctype html><html lang=cn-zh><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Hi, I'm Vimiix</title><meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title="Hi, I'm Vimiix"></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1><a href=https://www.vimiix.com/posts/2018-07-26-channels2-tutorial/>Django Channels2.0 websocket最佳实践</a></h1><b><time>2018.07.26 02:56</time></b>
<a href=/tags/django>Django</a>
<a href=/tags/channels>Channels</a>
<a href=/tags/websocket>websocket</a><div><p>做 web 后端开发，少不了要和 websocket 打交道。之前写过一篇关于 websocket 的实践文章 &mdash; <a href=https://vimiix.com/post/2018/04/02/python-websocket/>《[python]记录关于 websocket 的原理和使用》</a> ，不过，从 GITHUB 上可以看到，<strong>django-websocket</strong> 这个开源项目俨然已经是一个被放弃了的坑，并且在使用的过程中确实也有很多坑，果断弃之。</p><p>今天想聊的就是目前业界大牛都在推荐的一个框架&ndash;<a href=https://github.com/django/channels>Channels</a>， Channels 是针对 Django 项目的一个增强框架，它可以是的同步的 Django 项目转变为异步的项目。它可以使得 Django 项目不仅支持 HTTP 请求，还可以支持 Websocket, chat 协议，IOT 协议 ，甚至是你自定义的协议，同时也整合了 Django 的 auth 以及 session 系統等等。</p><a href=https://www.vimiix.com/posts/2018-07-26-channels2-tutorial/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-07-17-learn-contextlib/>浅谈Python中的上下文管理</a></h1><b><time>2018.07.18 00:56</time></b>
<a href=/tags/python>Python</a>
<a href=/tags/context>context</a><div><h2 id=with-语法>with 语法</h2><p>平常在写 Python 代码的时候，经常会用到<code>with</code> 来处理一个上下文环境，比如文件的打开关闭，数据库的连接关闭等等。</p><p><code>with</code>语法的使用，需要我们处理的对象实现<code>__enter__</code>和<code>__exit__</code>两个魔术方法来支持。<code>__enter__</code>函数处理逻辑函数之前需要做的事情，并返回操作对象作为<code>as</code>后面的变量，<code>__exit__</code>函数处理当代码离开<code>with</code>代码块以后的事情。</p><p><code>with</code>语法非常方便的让我使用资源并且不用操心忘记后续操作所带来的隐患。</p><a href=https://www.vimiix.com/posts/2018-07-17-learn-contextlib/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-05-grokking-algorithms-chapter-7/>《算法图解》读书笔记7-狄克斯特拉算法</a></h1><b><time>2018.07.16 22:20</time></b>
<a href=/tags/algorithm>algorithm</a>
<a href=/tags/python>Python</a>
<a href=/tags/dijkstra>Dijkstra</a><div><h2 id=概念>概念</h2><blockquote><p>狄克斯特拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题 (该算法不能处理包含负边的图)。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p></blockquote><a href=https://www.vimiix.com/posts/2018-06-05-grokking-algorithms-chapter-7/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-07-02-wake-up-time/>跳槽</a></h1><b><time>2018.07.02 14:36</time></b>
<a href=/tags/%E7%94%9F%E6%B4%BB>生活</a>
<a href=/tags/%E8%B7%B3%E6%A7%BD>跳槽</a><div>不知不觉，一个月没有写东西。感觉很快，因为没有感觉；但又感觉很慢，因为心理一直在作斗争。
这将近一个月的时间里，我基本没有和圈内的朋友交流，自己都感觉自己像蒸发了一样。这一个月的经过，给我积累了人生的一次重要经验——项目一定要选对人。剩下的就留给时间去消化吧。
今天以后，我将继续恢复日常的上班，学习，记录生活。
今天，北京天气很好。趁着阳光正好，我正式入职豆瓣了。
豆瓣，因为喜欢 python，慕名而来。
希望自己未来可以在这个 python 的"伊甸园"里面茁壮地成长！</div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-04-python-destructor-and-garbage-collection-notes/>[译]python中垃圾回收和析构函数笔记</a></h1><b><time>2018.06.04 14:36</time></b>
<a href=/tags/gc>GC</a>
<a href=/tags/python>Python</a><div><blockquote><p>紧接上一篇转载的文章<a href=https://vimiix.com/post/2018/06/04/python-magic-methods/>《Python 魔术方法总结》</a>文末提及的英文参考文章，洒家顺手就翻译了一下。方便墙内的同学学习。这篇文章不仅指出了 Python 如何处理垃圾回收，还提到了我们作为程序员不应该只借助现代化 IDE 的函数提示功能去完成代码，应该多去看官方的完整文档，可以知道哪些函数被废弃的，哪些函数在使用时需要注意什么等等一些很重要的信息。话不多说，自己体会，请向下阅读文章吧。</p><p>原文链接：<a href=https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/>https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/</a></p></blockquote><p>我很少在 Python 对象中使用析构函数。我猜 Python 的动态特性往往弱化了对析构函数的需求。但是现在，假如我需要在对象被销毁时，或者更确切地说，当程序退出时，要将一些数据写入磁盘。这时我会使用<code>__del__</code> 魔术方法在主要操作的类对象中定义了一个析构函数。但是奇怪的是，这个析构函数自始至终都没有被调用到。不仅在程序退出时没有被调用到，而且我手动使用<code>del</code>删除时也不会被调用。由于这个程序是我前一段时间写的，所有稍微有点不是很熟悉了，这导致我怀疑是我程序中有一个大的 BUG 存在。</p><a href=https://www.vimiix.com/posts/2018-06-04-python-destructor-and-garbage-collection-notes/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-04-python-magic-methods/>[转]Python中的魔术方法汇总</a></h1><b><time>2018.06.04 13:20</time></b>
<a href=/tags/magic-method>magic method</a>
<a href=/tags/python>Python</a><div><blockquote><p>这是一篇很不错的总结文章，简单易理解，洒家忍不住要转载收藏一下。</p><p>源文链接：<a href="http://algo.site/?cat=60">http://algo.site/?cat=60</a></p></blockquote><h3 id=基础>基础:</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>初始化一个实例</td><td><code>x = MyClass()</code></td><td><code>x.__init__()</code></td></tr><tr><td>作为一个字符串的"官方"表示</td><td><code>repr(x)</code></td><td><code>x.__repr__()</code></td></tr><tr><td>作为一个字符串</td><td><code>str(x)</code></td><td><code>x.__str__()</code></td></tr><tr><td>作为字节数组</td><td><code>bytes(x)</code></td><td><code>x.__bytes__()</code></td></tr><tr><td>作为格式化字符串</td><td><code>format(x, format_spec)</code></td><td><code>x.__format__(format_spec)</code></td></tr></tbody></table><a href=https://www.vimiix.com/posts/2018-06-04-python-magic-methods/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-03-grokking-algorithms-chapter-6/>《算法图解》读书笔记6-图以及广度优先搜索</a></h1><b><time>2018.06.03 16:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><h2 id=什么是图>什么是图</h2><p>图模拟一组链接，图由顶点和边组成。一个顶点可能与众多顶点直接相连，这些顶点被称为<strong>邻居</strong>。</p><p>图通常表示为：<code>G(V,E)</code>，其中，<code>G</code>表示一个图，<code>V</code>是图中顶点的集合，<code>E</code>是图中边的集合。</p><h4 id=简单图>简单图</h4><p>在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则这样的图称之为简单图。</p><h4 id=无向图>无向图</h4><p>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。</p><p>无向边：若顶点 M 到顶点 N 的边没有方向，称这条边为无向边，用无序偶对(M,N)或(N,M)表示。</p><a href=https://www.vimiix.com/posts/2018-06-03-grokking-algorithms-chapter-6/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-02-grokking-algorithms-chapter-5/>《算法图解》读书笔记5-散列函数及扩展</a></h1><b><time>2018.06.02 16:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><h2 id=散列函数>散列函数</h2><p>散列函数就是一种<strong>映射</strong>，是从关键字到存储地址的映射。通常，包含散列函数的算法的算法复杂度都为 O(1)，对应到 Python 中的数据结构就是字典，给一个 key 可以得到一个固定的 value 值。散列函数必须满足一些要求：</p><ul><li>它必须是一直的。例如，假设输入 apple 时得到的是 4，那么每次输入 apple 时，都必须是 4，不然这个散列函数就是无意义的；</li><li>散列函数应该将不同的输入值，对应到不同的值上。（虽然不同的 key 对应相同的 value 是允许的，但最理想的情况是不同的 key，对应不同的 value，这种称之为<a href=https://zh.wikipedia.org/wiki/%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97>完美散列</a>）</li></ul><a href=https://www.vimiix.com/posts/2018-06-02-grokking-algorithms-chapter-5/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-30-grokking-algorithms-chapter-4/>《算法图解》读书笔记4-分治思想和快排</a></h1><b><time>2018.05.30 16:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><h2 id=分而治之divide-and-conquer>分而治之（Divide and Conquer）</h2><p>所谓分而治之，分为分解问题，但我们目的是解决大问题，所有还有将分解后得到的结果贡献回大问题，最终使得我们解决大问题。</p><p>分而治之的思想是采用了递归的思想，将原问题分成几个规模较小但是<strong>类似</strong>于原问题的子问题， 通过递归的方式来求解这些小问题，最后将子问题的解合并来得到原问题的解。分治思想的本质是我们中学时候学的数学归纳法。</p><p>书上提到，使用分治思想解决问题的过程包括两个步骤，其实应该是三个步骤：</p><ol><li>找出基线条件，这种条件必须尽可能简单。</li><li>不断将问题分解为子问题（或者说缩小规模），直达符合基线条件。</li><li>合并子问题的结果，得到最终问题的解（利用系统栈的特性实现过程状态的记录）</li></ol><a href=https://www.vimiix.com/posts/2018-05-30-grokking-algorithms-chapter-4/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-25-grokking-algorithms-chapter-2/>《算法图解》读书笔记2-数组链表和选择排序</a></h1><b><time>2018.05.25 19:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>linux</a>
<a href=/tags/sort>sort</a><div><h2 id=理解数组和链表>理解数组和链表</h2><p>链表和数组是两种基本的数据结构，他们的区别在于数据在内存中的存储方式不同。</p><h3 id=数组>数组</h3><p>数组在内存中是用一块连续的内存来存储数据的，数组中的每个数据地址是连续的。数组中的每个元素所占用的内存是相同的，所以，我们可以通过下标索引在常数数量级的时间内，迅速访问数组中的任何一个元素。但是要在数组中任意位置添加一个元素，就需要移动大量的元素，使得内存中空出一个位置来存放新插入的元素。同理，当删除一个元素的时候，也需要移动大量的元素，来使得删除元素以后的数组数据在内存中仍旧是连续的。</p><p>由此可见：当对于一组数据，读取操作频繁，写操作少的情况，应该使用数组数据结构。</p><a href=https://www.vimiix.com/posts/2018-05-25-grokking-algorithms-chapter-2/>Read more...</a></div></article><div><a href=/page/2/>上一页</a>
3 of 8
<a href=/page/4/>下一页</a></div></main><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2022
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>