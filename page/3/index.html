<!doctype html><html lang=cn-zh><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Hi, I'm Vimiix</title><meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title="Hi, I'm Vimiix"></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1><a href=https://www.vimiix.com/posts/2018-06-05-grokking-algorithms-chapter-7/>《算法图解》读书笔记7-狄克斯特拉算法</a></h1><b><time>2018.07.16 22:20</time></b>
<a href=/tags/algorithm>algorithm</a>
<a href=/tags/python>Python</a>
<a href=/tags/dijkstra>Dijkstra</a><div><h2 id=概念>概念</h2><blockquote><p>狄克斯特拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题 (该算法不能处理包含负边的图)。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p></blockquote><a href=https://www.vimiix.com/posts/2018-06-05-grokking-algorithms-chapter-7/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-07-02-wake-up-time/>跳槽</a></h1><b><time>2018.07.02 14:36</time></b>
<a href=/tags/%E7%94%9F%E6%B4%BB>生活</a>
<a href=/tags/%E8%B7%B3%E6%A7%BD>跳槽</a><div>不知不觉，一个月没有写东西。感觉很快，因为没有感觉；但又感觉很慢，因为心理一直在作斗争。
这将近一个月的时间里，我基本没有和圈内的朋友交流，自己都感觉自己像蒸发了一样。这一个月的经过，给我积累了人生的一次重要经验——项目一定要选对人。剩下的就留给时间去消化吧。
今天以后，我将继续恢复日常的上班，学习，记录生活。
今天，北京天气很好。趁着阳光正好，我正式入职豆瓣了。
豆瓣，因为喜欢 python，慕名而来。
希望自己未来可以在这个 python 的"伊甸园"里面茁壮地成长！</div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-04-python-destructor-and-garbage-collection-notes/>[译]python中垃圾回收和析构函数笔记</a></h1><b><time>2018.06.04 14:36</time></b>
<a href=/tags/gc>GC</a>
<a href=/tags/python>Python</a><div><blockquote><p>紧接上一篇转载的文章<a href=https://vimiix.com/post/2018/06/04/python-magic-methods/>《Python 魔术方法总结》</a>文末提及的英文参考文章，洒家顺手就翻译了一下。方便墙内的同学学习。这篇文章不仅指出了 Python 如何处理垃圾回收，还提到了我们作为程序员不应该只借助现代化 IDE 的函数提示功能去完成代码，应该多去看官方的完整文档，可以知道哪些函数被废弃的，哪些函数在使用时需要注意什么等等一些很重要的信息。话不多说，自己体会，请向下阅读文章吧。</p><p>原文链接：<a href=https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/>https://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/</a></p></blockquote><p>我很少在 Python 对象中使用析构函数。我猜 Python 的动态特性往往弱化了对析构函数的需求。但是现在，假如我需要在对象被销毁时，或者更确切地说，当程序退出时，要将一些数据写入磁盘。这时我会使用<code>__del__</code> 魔术方法在主要操作的类对象中定义了一个析构函数。但是奇怪的是，这个析构函数自始至终都没有被调用到。不仅在程序退出时没有被调用到，而且我手动使用<code>del</code>删除时也不会被调用。由于这个程序是我前一段时间写的，所有稍微有点不是很熟悉了，这导致我怀疑是我程序中有一个大的 BUG 存在。</p><a href=https://www.vimiix.com/posts/2018-06-04-python-destructor-and-garbage-collection-notes/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-04-python-magic-methods/>[转]Python中的魔术方法汇总</a></h1><b><time>2018.06.04 13:20</time></b>
<a href=/tags/magic-method>magic method</a>
<a href=/tags/python>Python</a><div><blockquote><p>这是一篇很不错的总结文章，简单易理解，洒家忍不住要转载收藏一下。</p><p>源文链接：<a href="http://algo.site/?cat=60">http://algo.site/?cat=60</a></p></blockquote><h3 id=基础>基础:</h3><table><thead><tr><th>如果你想…</th><th>所以,你写…</th><th>Python 调用…</th></tr></thead><tbody><tr><td>初始化一个实例</td><td><code>x = MyClass()</code></td><td><code>x.__init__()</code></td></tr><tr><td>作为一个字符串的"官方"表示</td><td><code>repr(x)</code></td><td><code>x.__repr__()</code></td></tr><tr><td>作为一个字符串</td><td><code>str(x)</code></td><td><code>x.__str__()</code></td></tr><tr><td>作为字节数组</td><td><code>bytes(x)</code></td><td><code>x.__bytes__()</code></td></tr><tr><td>作为格式化字符串</td><td><code>format(x, format_spec)</code></td><td><code>x.__format__(format_spec)</code></td></tr></tbody></table><a href=https://www.vimiix.com/posts/2018-06-04-python-magic-methods/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-03-grokking-algorithms-chapter-6/>《算法图解》读书笔记6-图以及广度优先搜索</a></h1><b><time>2018.06.03 16:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><h2 id=什么是图>什么是图</h2><p>图模拟一组链接，图由顶点和边组成。一个顶点可能与众多顶点直接相连，这些顶点被称为<strong>邻居</strong>。</p><p>图通常表示为：<code>G(V,E)</code>，其中，<code>G</code>表示一个图，<code>V</code>是图中顶点的集合，<code>E</code>是图中边的集合。</p><h4 id=简单图>简单图</h4><p>在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则这样的图称之为简单图。</p><h4 id=无向图>无向图</h4><p>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。</p><p>无向边：若顶点 M 到顶点 N 的边没有方向，称这条边为无向边，用无序偶对(M,N)或(N,M)表示。</p><a href=https://www.vimiix.com/posts/2018-06-03-grokking-algorithms-chapter-6/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-06-02-grokking-algorithms-chapter-5/>《算法图解》读书笔记5-散列函数及扩展</a></h1><b><time>2018.06.02 16:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><h2 id=散列函数>散列函数</h2><p>散列函数就是一种<strong>映射</strong>，是从关键字到存储地址的映射。通常，包含散列函数的算法的算法复杂度都为 O(1)，对应到 Python 中的数据结构就是字典，给一个 key 可以得到一个固定的 value 值。散列函数必须满足一些要求：</p><ul><li>它必须是一直的。例如，假设输入 apple 时得到的是 4，那么每次输入 apple 时，都必须是 4，不然这个散列函数就是无意义的；</li><li>散列函数应该将不同的输入值，对应到不同的值上。（虽然不同的 key 对应相同的 value 是允许的，但最理想的情况是不同的 key，对应不同的 value，这种称之为<a href=https://zh.wikipedia.org/wiki/%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97>完美散列</a>）</li></ul><a href=https://www.vimiix.com/posts/2018-06-02-grokking-algorithms-chapter-5/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-30-grokking-algorithms-chapter-4/>《算法图解》读书笔记4-分治思想和快排</a></h1><b><time>2018.05.30 16:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><h2 id=分而治之divide-and-conquer>分而治之（Divide and Conquer）</h2><p>所谓分而治之，分为分解问题，但我们目的是解决大问题，所有还有将分解后得到的结果贡献回大问题，最终使得我们解决大问题。</p><p>分而治之的思想是采用了递归的思想，将原问题分成几个规模较小但是<strong>类似</strong>于原问题的子问题， 通过递归的方式来求解这些小问题，最后将子问题的解合并来得到原问题的解。分治思想的本质是我们中学时候学的数学归纳法。</p><p>书上提到，使用分治思想解决问题的过程包括两个步骤，其实应该是三个步骤：</p><ol><li>找出基线条件，这种条件必须尽可能简单。</li><li>不断将问题分解为子问题（或者说缩小规模），直达符合基线条件。</li><li>合并子问题的结果，得到最终问题的解（利用系统栈的特性实现过程状态的记录）</li></ol><a href=https://www.vimiix.com/posts/2018-05-30-grokking-algorithms-chapter-4/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-25-grokking-algorithms-chapter-2/>《算法图解》读书笔记2-数组链表和选择排序</a></h1><b><time>2018.05.25 19:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>linux</a>
<a href=/tags/sort>sort</a><div><h2 id=理解数组和链表>理解数组和链表</h2><p>链表和数组是两种基本的数据结构，他们的区别在于数据在内存中的存储方式不同。</p><h3 id=数组>数组</h3><p>数组在内存中是用一块连续的内存来存储数据的，数组中的每个数据地址是连续的。数组中的每个元素所占用的内存是相同的，所以，我们可以通过下标索引在常数数量级的时间内，迅速访问数组中的任何一个元素。但是要在数组中任意位置添加一个元素，就需要移动大量的元素，使得内存中空出一个位置来存放新插入的元素。同理，当删除一个元素的时候，也需要移动大量的元素，来使得删除元素以后的数组数据在内存中仍旧是连续的。</p><p>由此可见：当对于一组数据，读取操作频繁，写操作少的情况，应该使用数组数据结构。</p><a href=https://www.vimiix.com/posts/2018-05-25-grokking-algorithms-chapter-2/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-27-grokking-algorithms-chapter-3/>《算法图解》读书笔记3-递归</a></h1><b><time>2018.05.25 19:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><blockquote><p>如果使用循环 ，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。</p></blockquote><h2 id=递归函数>递归函数</h2><p>在一个函数中，可以调用另一个函数，如果调用的另一个函数是函数本身，这样的函数就是递归函数。如下示例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(x):
    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;end&#39;</span>
    <span style=color:#66d9ef>else</span>:
        <span style=color:#75715e># 在函数中继续调用自己</span>
        <span style=color:#66d9ef>return</span> foo(x<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</code></pre></div><a href=https://www.vimiix.com/posts/2018-05-27-grokking-algorithms-chapter-3/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-21-grokking-algorithms-chapter-1/>《算法图解》读书笔记1-二分和大O</a></h1><b><time>2018.05.23 23:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><blockquote><p>算法是一组完成任务的指令</p></blockquote><h2 id=为什么要学习算法>为什么要学习算法</h2><p>这次是我第二次读《算法图解》，当我第一次看这本书的时候，我更兴奋于书中有什么内容，迫不及待的去过内容，学习那些算法概念。但当我第二次准备开始读这本书的时候，我脑海中出现的了一个问题：“为什么要学习算法？”，这个问题也许会有人和我一样，之前根本没有好好的去思考，只是知道，作为一个程序员我应该学习算法。当然，能够有这个觉悟，说明我们还算是个合格的程序员。</p><p>但是，不妨认真思考一下，为什么要学习算法？算法应该怎么学？</p><a href=https://www.vimiix.com/posts/2018-05-21-grokking-algorithms-chapter-1/>Read more...</a></div></article><div><a href=/page/2/>上一页</a>
3 of 8
<a href=/page/4/>下一页</a></div></main><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2021
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>