<!doctype html><html lang=cn-zh><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Hi, I'm Vimiix</title><meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title="Hi, I'm Vimiix"></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1><a href=https://www.vimiix.com/posts/2018-05-27-grokking-algorithms-chapter-3/>《算法图解》读书笔记3-递归</a></h1><b><time>2018.05.25 19:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><blockquote><p>如果使用循环 ，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。</p></blockquote><h2 id=递归函数>递归函数</h2><p>在一个函数中，可以调用另一个函数，如果调用的另一个函数是函数本身，这样的函数就是递归函数。如下示例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(x):
    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;end&#39;</span>
    <span style=color:#66d9ef>else</span>:
        <span style=color:#75715e># 在函数中继续调用自己</span>
        <span style=color:#66d9ef>return</span> foo(x<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</code></pre></div><a href=https://www.vimiix.com/posts/2018-05-27-grokking-algorithms-chapter-3/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-21-grokking-algorithms-chapter-1/>《算法图解》读书笔记1-二分和大O</a></h1><b><time>2018.05.23 23:20</time></b>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/linux>Linux</a><div><blockquote><p>算法是一组完成任务的指令</p></blockquote><h2 id=为什么要学习算法>为什么要学习算法</h2><p>这次是我第二次读《算法图解》，当我第一次看这本书的时候，我更兴奋于书中有什么内容，迫不及待的去过内容，学习那些算法概念。但当我第二次准备开始读这本书的时候，我脑海中出现的了一个问题：“为什么要学习算法？”，这个问题也许会有人和我一样，之前根本没有好好的去思考，只是知道，作为一个程序员我应该学习算法。当然，能够有这个觉悟，说明我们还算是个合格的程序员。</p><p>但是，不妨认真思考一下，为什么要学习算法？算法应该怎么学？</p><a href=https://www.vimiix.com/posts/2018-05-21-grokking-algorithms-chapter-1/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-18-tpli-io-extend/>TLPI笔记—深入文件I/O模型</a></h1><b><time>2018.05.18 09:20</time></b>
<a href=/tags/tlpi>tlpi</a>
<a href=/tags/linux>Linux</a>
<a href=/tags/note>note</a>
<a href=/tags/i/o>I/O</a><div><h2 id=原子操作和竞争操作>原子操作和竞争操作</h2><p>所有的系统调用都是以原子操作方式执行的。之所以这么说，是指内核保证了某系统调用中的所有步骤会作为地理操作而一次性加以执行，期间不会被其他进程或线程中断。原子性规避了<strong>竞争状态（race condition）</strong>，竞争状态指：操作共享资源的两个进程（或线程）其结果取决于一个无法预期的顺序，即这些进程或线程获得 CPU 使用权的先后相对顺序。</p><a href=https://www.vimiix.com/posts/2018-05-18-tpli-io-extend/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-11-tpli-common-io/>TLPI笔记—通用文件I/O模型</a></h1><b><time>2018.05.11 09:20</time></b>
<a href=/tags/tlpi>tlpi</a>
<a href=/tags/linux>Linux</a>
<a href=/tags/note>note</a>
<a href=/tags/i/o>I/O</a><div><h2 id=文件描述符>文件描述符</h2><p>所有执行 I/O 操作的系统调用都是以文件描述符，一个非负整数来指代打开的文件。文件描述符用以表示所有类型的已打开的文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。每个进程都各自独立维护着一张文件描述符表。</p><h3 id=标准文件描述符>标准文件描述符</h3><table><thead><tr><th style=text-align:center>文件描述符</th><th style=text-align:center>用途</th><th style=text-align:center>POSIX 名称</th><th style=text-align:center>stdio 流</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>标准输入</td><td style=text-align:center>STDIN_FILENO</td><td style=text-align:center>stdin</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>标准输出</td><td style=text-align:center>STDOUT_FILENO</td><td style=text-align:center>stdout</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>标准错误</td><td style=text-align:center>STDERR_FILENO</td><td style=text-align:center>stderr</td></tr></tbody></table><a href=https://www.vimiix.com/posts/2018-05-11-tpli-common-io/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-05-01-linux-history/>TPLI笔记—linux/unix标准和历史</a></h1><b><time>2018.05.01 19:20</time></b>
<a href=/tags/tlpi>tlpi</a>
<a href=/tags/linux>Linux</a>
<a href=/tags/note>note</a>
<a href=/tags/posix>POSIX</a><div><h2 id=前言>前言</h2><p>最近开始阅读<a href=https://book.douban.com/subject/25809330/>《Linux/Unix 系统编程手册》</a> 这本书，重新系统的学习一下 linux 系统编程方面的知识。</p><p>在阅读完第一章《历史和标准》以后，对于很多标准名词都见过，但是对于他们之间的发展历程很是模糊，通读这部分内容后豁然开朗，尤其本章最后总结部分，对于前面的概况的既简练还没有遗漏。不禁在书上用笔写下：<strong>“牛 B 总结，一气呵成”</strong>。</p><p>方便以后不去翻书回顾，特花点时间摘录至此。</p><a href=https://www.vimiix.com/posts/2018-05-01-linux-history/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-04-02-python-websocket/>[python]记录关于websocket的原理和使用</a></h1><b><time>2018.04.02 19:20</time></b>
<a href=/tags/python>Python</a>
<a href=/tags/websocket>websocket</a>
<a href=/tags/note>note</a>
<a href=/tags/django>django</a><div><h2 id=什么是-websocket>什么是 websocket</h2><p>WebSocket 是一种在单个 TCP 连接上进行<a href=https://zh.wikipedia.org/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5>全双工</a>通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建<strong>持久性</strong>的连接，并进行双向数据传输。</p><p>Websocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说的。</p><p>举个例子：</p><blockquote><p>HTTP 的生命周期通过 Request 来界定，也就是发送一次 Request，收到一次 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了</p><p>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response ， 在 HTTP 中永远是这样，也就是说一个 request 只能有一个 response。而且这个 response 也是被动的，不能主动发起。</p><p>而对于 websocket 来说，在 HTTP 的握手基础上建立起链接，服务器端可以主动的向客户端发送数据。</p></blockquote><a href=https://www.vimiix.com/posts/2018-04-02-python-websocket/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-03-18-git-push-hangs-on-chunked/>[笔记]git push卡主不动问题记录：Git push hangs on POST git-receive-pack</a></h1><b><time>2018.03.18 18:20</time></b>
<a href=/tags/git>git</a>
<a href=/tags/note>note</a>
<a href=/tags/solution>solution</a><div><h2 id=问题>问题</h2><p>昨天完成了<a href=https://github.com/pythonzhichan/django-beginners-guide/blob/master/ClassBasedViews.md>《一个完整的 Django 入门指南》 - 第 6 部分</a>的翻译工作，本地在翻译的过程中，存储了十几张原文中的 <code>png</code> 格式的插图。</p><p>在 <code>git push</code> 提交 <strong>github</strong> 仓库的时候，终端显示写成功 100%, 但是一直卡在了下面这里没有推送成功：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Counting objects: 21, <span style=color:#66d9ef>done</span>.
Delta compression using up to <span style=color:#ae81ff>8</span> threads.
Compressing objects: 100% <span style=color:#f92672>(</span>21/21<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
Writing objects: 100% <span style=color:#f92672>(</span>21/21<span style=color:#f92672>)</span>, 1018.52 KiB | 17.87 MiB/s, <span style=color:#66d9ef>done</span>.
Total <span style=color:#ae81ff>21</span> <span style=color:#f92672>(</span>delta 7<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
<span style=color:#75715e># 卡在这里</span>
</code></pre></div><a href=https://www.vimiix.com/posts/2018-03-18-git-push-hangs-on-chunked/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-03-11-manage-your-virtualenv-with-pipenv/>[Python]使用pipenv管理python虚拟环境</a></h1><b><time>2018.03.11 18:20</time></b>
<a href=/tags/pipenv>pipenv</a>
<a href=/tags/autoenv>autoenv</a>
<a href=/tags/python>Python</a>
<a href=/tags/virtualenv>virtualenv</a><div><h2 id=前言>前言</h2><p>近期的项目中，我开始尝试着从 virtualenv 管理 python 虚拟环境，切换到用 pipenv 来管理。</p><p>经过一段时间的使用，着实觉得 pipenv 使用的更加顺手，更加的便捷。这当然也延续了 <a href=https://www.kennethreitz.org/>Kenneth</a> 大神一贯的项目作风&ndash; <strong><code>For Humans</code></strong> 。</p><p>再配合上 <strong><code>autoenv</code></strong>（自动激活虚拟环境的工具），更加的 Perfect！</p><a href=https://www.vimiix.com/posts/2018-03-11-manage-your-virtualenv-with-pipenv/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-02-26-first-practise-of-uvicorn/>[Python]Uvicorn初体验</a></h1><b><time>2018.02.26 12:20</time></b>
<a href=/tags/uvicorn>uvicorn</a>
<a href=/tags/web>web</a>
<a href=/tags/python>Python</a>
<a href=/tags/asyncio>asyncio</a><div><h2 id=uvicorn-简介>uvicorn 简介</h2><p><code>uvicorn</code>是一个基于<code>asyncio</code>开发的一个轻量级高效的 web 服务器框架。</p><blockquote><p>官网：<a href=http://www.uvicorn.org>http://www.uvicorn.org</a></p></blockquote><p><code>uvicorn</code> 设计的初衷是想要实现两个目标：</p><ul><li>使用<a href=https://github.com/MagicStack/uvloop><code>uvloop</code></a>和<a href=https://github.com/MagicStack/httptools><code>httptools</code></a>实现一个极速的<code>asyncio</code>服务器。</li><li>实现一个基于<a href=http://channels.readthedocs.io/en/stable/asgi.html><code>ASGI(异步服务器网关接口)</code></a>的最小的应用程序接口。</li></ul><p>它目前支持<code>http</code>，<code>websockets</code>，<code>Pub/Sub</code> 广播，并且可以扩展到其他协议和消息类型。</p><a href=https://www.vimiix.com/posts/2018-02-26-first-practise-of-uvicorn/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2018-02-07-dp-note/>[算法笔记]动态规划之最长公共子串和最长公共子序列</a></h1><b><time>2018.02.07 12:27</time></b>
<a href=/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92>动态规划</a>
<a href=/tags/algorithms>algorithms</a>
<a href=/tags/python>Python</a><div><blockquote><p>本文是《算法图解》笔记</p></blockquote><h2 id=应用场景>应用场景</h2><p>一切脱离实际应用场景的算法都是耍流氓！</p><ul><li>生物学家根据最长公共序列来确定 DNA 链的相似性，进而判断两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。</li><li>源代码管理中，<code>git diff</code>指令，可以查找出编辑前后文件的差异，这是基于动态规划实现的。</li><li>编辑距离（<code>levenshtein distance</code>），判断字符串的相似程度，也是基于动态规划计算。可以通过这个技术从拼写检查到判断用户上传的资料是否是盗版。（<em>这样看来，我猜想大学论文查重应该也是基于动态规划算法:P</em>）</li><li>Microsoft Word 等软件中具有断字功能，使用动态规划可以确定什么地方断字以确保行长一致。</li></ul><a href=https://www.vimiix.com/posts/2018-02-07-dp-note/>Read more...</a></div></article><div><a href=/page/3/>上一页</a>
4 of 8
<a href=/page/5/>下一页</a></div></main><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2021
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>