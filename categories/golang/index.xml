<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Hi, I'm Vimiix</title><link>https://vimiix.com/categories/golang/</link><description>Recent content in golang on Hi, I'm Vimiix</description><generator>Hugo -- gohugo.io</generator><language>cn-zh</language><copyright>Copyright (c) 2017-2021, Vimiix Yao; All rights reserved</copyright><lastBuildDate>Mon, 22 Mar 2021 16:22:48 +0000</lastBuildDate><atom:link href="https://vimiix.com/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang实现Windows系统用户和密码校验</title><link>https://vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/</link><pubDate>Mon, 22 Mar 2021 16:22:48 +0000</pubDate><guid>https://vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/</guid><description>本质上是通过调用 windows 的一个 API —— LogonUserW ，来实现对于用户密码的校验。
仅适用于在本地校验，不支持远程连接校验
用一个示例代码来进行说明，下面是目录结构中，main.go 是程序入口文件，auth 包中，我们仅实现 windows 系统的校验代码，其他平台不属于本文介绍内容，就直接返回 nil 即可。
目录结构 . ├── auth │ ├── auth.go │ └── auth_windows.go ├── go.mod └── main.go 源代码 [src] main.go package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.com/vimiix/authDemo/auth&amp;#34; ) func main() { user := flag.String(&amp;#34;u&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;username&amp;#34;) password := flag.String(&amp;#34;p&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;password&amp;#34;) flag.Parse() if *user == &amp;#34;&amp;#34; || *password == &amp;#34;&amp;#34; { fmt.Println(&amp;#34;Both user and password should be specify&amp;#34;) fmt.</description></item><item><title>Golang实现Google在RTB广告中价格加密方案</title><link>https://vimiix.com/posts/2019-11-13-google-rtb-price-in-golang/</link><pubDate>Wed, 13 Nov 2019 16:22:48 +0000</pubDate><guid>https://vimiix.com/posts/2019-11-13-google-rtb-price-in-golang/</guid><description>RTB RTB 广告是一种实时竞价广告，就是在针对每个广告位有展示机会的时候，会实时多方竞价，价格最有优势的广告主会竞得这次展示机会，在媒体测在拿到素材的时候，需将本次成交的价格，上报给指定的监控服务器，这时就需要将实时价格按照指定的加密方案加密后，替换 GET 链接中的请求参数中的价格宏来上报。
官方给出的源代码有 Java 和 C++ 版本, 下载地址： https://code.google.com/archive/p/privatedatacommunicationprotocol/source/default/source
本文主要通过 golang 来实现的 google 的价格加密方案。
Source Code package main /* golang 实现 google 的rtb 价格加密方案 https://developers.google.com/authorized-buyers/rtb/response-guide/decrypt-price#encryption-scheme */ import ( &amp;#34;crypto/hmac&amp;#34; &amp;#34;crypto/md5&amp;#34; &amp;#34;crypto/sha1&amp;#34; &amp;#34;encoding/base64&amp;#34; &amp;#34;encoding/binary&amp;#34; &amp;#34;encoding/hex&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;hash&amp;#34; &amp;#34;math&amp;#34; &amp;#34;strings&amp;#34; ) const ( PayloadSize = 8 InitVectorSize = 16 SignatureSize = 4 EKey = &amp;#34;&amp;#34; IKey = &amp;#34;&amp;#34; UTF8 = &amp;#34;utf-8&amp;#34; ) func AddBase64Padding(base64Input string) string { var b64 string b64 = base64Input if i := len(b64) % 4; i !</description></item><item><title>Golang如何确保一个类型实现了某个interface</title><link>https://vimiix.com/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</link><pubDate>Thu, 29 Aug 2019 16:22:48 +0000</pubDate><guid>https://vimiix.com/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</guid><description>在 golang 中，接口（interface）代表一种『协议』存在，它是一个声明了多个方法的集合。
接口是被隐式实现的，也就是说，我们在开发中定义一个类型（type）的时候，不需要声明这个类型实现了哪个接口。在使用的时候往往通过断言来的 ok-idom 来进行类型判断该类型是否实现了目标接口，放置调用方法失败抛出 panic：
if value, ok := AType.(BInterface) { fmt.Println(&amp;#34;ok&amp;#34;) } else { fmt.Println(&amp;#34;no&amp;#34;) } 如果断言失败，那么 ok 的值将会是 false,但是如果断言成功 ok 的值将会是 true,同时 value 将会得到所期待的正确的值。
但是，在某些情况下，我们可能希望明确地检查接口中哪些方法没有被实现。最好的方法就是借助编译器地检查功能。
假设定义了一个 Programmer 接口，一个 Human 类型：
&amp;raquo;&amp;gt; 试一下
package main type Programmer interface { Code() string } type Human struct {} func main() {} 这段代码没有做任何操作，可以正常地执行。
假设我们希望 Human 类型实现了 Programmer 接口，可以在代码中定义一个 _ （下划线表示忽略这个变量）变量来实现检测效果
package main type Programmer interface { Code() string } type Human struct {} // 利用编译器检查接口实现 var _ Programmer = (*Human)(nil) func main() {} 当再次执行这段代码地时候，就会报出如下编译错误：</description></item></channel></rss>