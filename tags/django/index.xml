<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Django on Hi, I'm Vimiix</title><link>https://vimiix.com/tags/django/</link><description>Recent content in Django on Hi, I'm Vimiix</description><generator>Hugo -- gohugo.io</generator><language>cn-zh</language><copyright>Copyright (c) 2017-2021, Vimiix Yao; All rights reserved</copyright><lastBuildDate>Thu, 26 Jul 2018 02:56:48 +0000</lastBuildDate><atom:link href="https://vimiix.com/tags/django/index.xml" rel="self" type="application/rss+xml"/><item><title>Django Channels2.0 websocket最佳实践</title><link>https://vimiix.com/posts/2018-07-26-channels2-tutorial/</link><pubDate>Thu, 26 Jul 2018 02:56:48 +0000</pubDate><guid>https://vimiix.com/posts/2018-07-26-channels2-tutorial/</guid><description>&lt;p>做 web 后端开发，少不了要和 websocket 打交道。之前写过一篇关于 websocket 的实践文章 &amp;mdash; &lt;a href="https://vimiix.com/post/2018/04/02/python-websocket/">《[python]记录关于 websocket 的原理和使用》&lt;/a> ，不过，从 GITHUB 上可以看到，&lt;strong>django-websocket&lt;/strong> 这个开源项目俨然已经是一个被放弃了的坑，并且在使用的过程中确实也有很多坑，果断弃之。&lt;/p>
&lt;p>今天想聊的就是目前业界大牛都在推荐的一个框架&amp;ndash;&lt;a href="https://github.com/django/channels">Channels&lt;/a>， Channels 是针对 Django 项目的一个增强框架，它可以是的同步的 Django 项目转变为异步的项目。它可以使得 Django 项目不仅支持 HTTP 请求，还可以支持 Websocket, chat 协议，IOT 协议 ，甚至是你自定义的协议，同时也整合了 Django 的 auth 以及 session 系統等等。&lt;/p></description></item><item><title>[python]记录关于websocket的原理和使用</title><link>https://vimiix.com/posts/2018-04-02-python-websocket/</link><pubDate>Mon, 02 Apr 2018 19:20:48 +0000</pubDate><guid>https://vimiix.com/posts/2018-04-02-python-websocket/</guid><description>&lt;h2 id="什么是-websocket">什么是 websocket&lt;/h2>
&lt;p>WebSocket 是一种在单个 TCP 连接上进行&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5">全双工&lt;/a>通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建&lt;strong>持久性&lt;/strong>的连接，并进行双向数据传输。&lt;/p>
&lt;p>Websocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说的。&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;blockquote>
&lt;p>HTTP 的生命周期通过 Request 来界定，也就是发送一次 Request，收到一次 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了&lt;/p>
&lt;p>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response ， 在 HTTP 中永远是这样，也就是说一个 request 只能有一个 response。而且这个 response 也是被动的，不能主动发起。&lt;/p>
&lt;p>而对于 websocket 来说，在 HTTP 的握手基础上建立起链接，服务器端可以主动的向客户端发送数据。&lt;/p>
&lt;/blockquote></description></item><item><title>[python]web框架中的代码自动重载怎么实现</title><link>https://vimiix.com/posts/2018-01-08-autoreload-code-in-python/</link><pubDate>Mon, 08 Jan 2018 22:37:48 +0000</pubDate><guid>https://vimiix.com/posts/2018-01-08-autoreload-code-in-python/</guid><description>&lt;p>在开发和调试 wsgi 应用程序时，有很多方法可以自动重新加载代码。例如，如果你使用的是&lt;code>werkzeug&lt;/code>，则只需要传&lt;code>use_reloader&lt;/code>参数即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">run_sumple(&lt;span style="color:#e6db74">&amp;#39;127.0.0.1&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>, app, use_reloader&lt;span style="color:#f92672">=&lt;/span>True)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 Flask,实际上在内部使用 werkzeug，所以你需要设置 debug = true：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">app&lt;span style="color:#f92672">.&lt;/span>run(debug&lt;span style="color:#f92672">=&lt;/span>True)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>django 会在你修改任何代码的时候自动为你重新加载：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">python manage&lt;span style="color:#f92672">.&lt;/span>py runserver
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有这些例子在本地开发的时候都非常有用，但是，建议不要在实际生产中使用。&lt;/p>
&lt;p>作为学习，可以一起来看一下，python 是如何让代码自动地重新加载的？&lt;/p></description></item><item><title>vmx-manager:基于django框架开发的cmdb系统</title><link>https://vimiix.com/posts/2017-07-18-vmx-manager-a-cmdb-system-base-on-django/</link><pubDate>Tue, 18 Jul 2017 22:58:21 +0000</pubDate><guid>https://vimiix.com/posts/2017-07-18-vmx-manager-a-cmdb-system-base-on-django/</guid><description>&lt;h2 id="系统介绍">系统介绍&lt;/h2>
&lt;p>VMX-Manager 是一个基于 Django 框架开发的一款 CMDB 管理系统，目前处于 beta 版本，功能主要包含: 管理系统管理的客户主机列表， 动态显示客户机状态信息，远程指令操作指定客户机以及主机与客户机之间的文件传输。&lt;/p></description></item><item><title>Web|关于cookie和session一点知识</title><link>https://vimiix.com/posts/2017-06-22-cookie-and-session/</link><pubDate>Thu, 22 Jun 2017 16:03:54 +0000</pubDate><guid>https://vimiix.com/posts/2017-06-22-cookie-and-session/</guid><description>&lt;h3 id="cookie维基百科定义httpszhwikipediaorgwikicookie">cookie(&lt;a href="https://zh.wikipedia.org/wiki/Cookie">维基百科定义&lt;/a>)&lt;/h3>
&lt;blockquote>
&lt;p>Cookie（复数形态 Cookies），中文名称为“小型文本文件”或“小甜饼”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。&lt;/p>
&lt;/blockquote></description></item></channel></rss>