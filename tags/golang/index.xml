<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Hi, I'm Vimiix</title><link>http://www.vimiix.com/vimiix-blog/tags/golang/</link><description>Recent content in golang on Hi, I'm Vimiix</description><generator>Hugo -- gohugo.io</generator><language>cn-zh</language><copyright>Copyright (c) 2017-2021, Vimiix Yao; All rights reserved</copyright><lastBuildDate>Fri, 15 Dec 2023 00:50:48 +0000</lastBuildDate><atom:link href="http://www.vimiix.com/vimiix-blog/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>SSX，一个有记忆的 ssh 客户端</title><link>http://www.vimiix.com/vimiix-blog/posts/2023-12-15-ssx/</link><pubDate>Fri, 15 Dec 2023 00:50:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2023-12-15-ssx/</guid><description>需求来源 对于一个后端程序员来说，在工作中免不了要和繁杂的服务器打交道，ssh 是不可或缺的开发工具。但每次登录都需要输入密码的行为，对于认为一切皆可自动化的程序员来说，肯定是有点繁琐的（如果您是使用图形化界面的用户可忽略）。
所以我在前段时间考虑，我应该自己实现一个 ssh 客户端，它不需要拥有许多复杂的功能，只需要满足我以下这几个需求即可满足日常使用：
和 ssh 保持差不多的使用习惯 仅在第一次登录时询问我密码，后续使用无需再提供密码 可以给服务器它任意的标签，这样我就可以自由地通过IP 或者标签来登录 于是乎，近期我在业余时间就设计并编写了 ssx 这个轻量级的具有记忆的 ssh 客户端。它完美的实现了上面我所需要的功能，也已经被我愉快的应用到了日常的开发中。
使用方式 下面就简单介绍一下 ssx 的使用方式。
ssx 是通过 golang 开发的一个独立的二进制文件，安装方式就是从 release 页面下载对应平台的软件包，解压后把 ssx 二进制放到系统的任意目录下，这里我习惯放到 /usr/local/bin 目录下，如果你选择其他目录下，需要确保存放的目录添加到 $PATH 环境变量中，这样后续使用我们就不用再添加路径前缀，直接通过 ssx 命令就可以运行了。
登录服务器 使用 ssx 登录服务器的时候，基本和 ssh 使用习惯一致，下面是基本命令模式：
ssx [-s] [USER@]HOST[:PORT] [-k IDENTITY_FILE] 在这个命令中，USER 是可以省略的，如果省略则是系统当前用户名；PORT 是可以省略的，默认是 22，-k IDENTITY_FILE 代表如果是使用私钥登录，则通过 -k 来指定私钥的路径，也是可以省略的，默认是 ~/.ssh/id_rsa，当然了，前提是这个文件存在。所以最精简的登录命令就是：ssx &amp;lt;ip&amp;gt;
当首次登录，不存在可用私钥时，会通过交互方式来让用户输入密码，一旦登录成功，这个密码就会被 ssx 保存到本地的数据文件中 (默认为 ~/.ssx/db， 可通过环境变量 SSX_DB_PATH 进行自定义)，下次登录时，仍然执行 ssx &amp;lt;ip&amp;gt; 即可自动登录。
注意，登录过的服务器，再次登录时，我嫌输入全部 IP 比较麻烦，所以 ssx 支持输入 IP 中的部分字符，自动搜索匹配进行登录。</description></item><item><title>Shell 函数实现Go语言多版本管理轻量级方案</title><link>http://www.vimiix.com/vimiix-blog/posts/2023-06-21-manage-go-multiple-versions/</link><pubDate>Wed, 21 Jun 2023 14:50:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2023-06-21-manage-go-multiple-versions/</guid><description>现有的工具方案 gvm: https://github.com/moovweb/gvm g: https://github.com/voidint/g 我的方案 优点：
原生：基于 go 语言本身支持多版本的能力实现，可以下载任何官方发布的版本 简单：shell 函数实现，直接集成到 bashrc 或 zshrc 中即可使用，无需额外配置 可定制化：代码简单可根据自身需求定制 代码实现 gist地址：https://gist.github.com/vimiix/0927fdfbea926e869a2c631db9eeae8b
####### GOLANG VERSION MANAGE FUNCTIONS ###### # ref: https://go.dev/doc/manage-install function goinstall() { echo &amp;#34;Downloading go$1 ...&amp;#34; go install golang.org/dl/go$1@latest &amp;amp;&amp;amp; go$1 download } function gouse() { gopath=$(go env GOPATH) if test -x ${gopath}/bin/go$1; then rm -f ${gopath}/bin/go echo &amp;#34;Relink go with go$1 ...&amp;#34; ln -s ${gopath}/bin/go$1 ${gopath}/bin/go echo &amp;#34;Done&amp;#34; else echo &amp;#34;Version $1 not installed&amp;#34; fi } function golist() { current=$(go version | awk &amp;#39;{print $3}&amp;#39; | cut -c3-) for v in $(ls $(go env GOPATH)/bin | grep -E &amp;#39;go(\d.</description></item><item><title>Golang的并行模式实践</title><link>http://www.vimiix.com/vimiix-blog/posts/2021-04-07-concurrency-in-go/</link><pubDate>Wed, 07 Apr 2021 18:15:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2021-04-07-concurrency-in-go/</guid><description>Goroutine C#、Lua、Python 的用户可能会发现 Go 的 goroutine 和协程之间有很多相似之处，没错，从命名上也可以看出二者具有相似性。
但二者之间也有些区别：
goroutine 隐含了并行的特性，一切交给 go 的 runtime 来实现调度，而协程需要应用自己来编写并行代码 goroutine 通过信道（Channel）进行通信；协程通过 yield 和 next操作进行通信 一般来说，goroutine 比协程更强大。而且，我们可以很容易地将协程的逻辑移植到 goroutine 来获得更好的并行效果。
Generators 在 python 中，要实现一个生成器，需要通过 yield 生成数据，通过 next 获取数据：
def integers(): i = 1 while True: yield i i+=1 integerGenerator = integers() next(integerGenerator) # 1 next(integerGenerator) # 2 next(integerGenerator) # 3 同样的，生成器也可以在 Go 中实现，只是使用了 channel 来代替 yield:
func integers () chan int { yield := make (chan int); count := 0; go func () { for { yield &amp;lt;- count; count++; } } (); return yield } next := integers(); func generateInteger () int { return &amp;lt;-next } generateInteger() // 0 generateInteger() // 1 generateInteger() // 2 Iterators go 的 channel 在语法层面就是天然的迭代器。</description></item><item><title>Golang实现Windows系统用户和密码校验</title><link>http://www.vimiix.com/vimiix-blog/posts/2021-03-22-auth-windows-user-in-golang/</link><pubDate>Mon, 22 Mar 2021 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2021-03-22-auth-windows-user-in-golang/</guid><description>本质上是通过调用 windows 的一个 API —— LogonUserW ，来实现对于用户密码的校验。
仅适用于在本地校验，不支持远程连接校验
用一个示例代码来进行说明，下面是目录结构中，main.go 是程序入口文件，auth 包中，我们仅实现 windows 系统的校验代码，其他平台不属于本文介绍内容，就直接返回 nil 即可。
目录结构 . ├── auth │ ├── auth.go │ └── auth_windows.go ├── go.mod └── main.go 源代码 [src] main.go package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.com/vimiix/authDemo/auth&amp;#34; ) func main() { user := flag.String(&amp;#34;u&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;username&amp;#34;) password := flag.String(&amp;#34;p&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;password&amp;#34;) flag.Parse() if *user == &amp;#34;&amp;#34; || *password == &amp;#34;&amp;#34; { fmt.Println(&amp;#34;Both user and password should be specify&amp;#34;) fmt.</description></item><item><title>Golang实现Google在RTB广告中价格加密方案</title><link>http://www.vimiix.com/vimiix-blog/posts/2019-11-13-google-rtb-price-in-golang/</link><pubDate>Wed, 13 Nov 2019 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2019-11-13-google-rtb-price-in-golang/</guid><description>RTB RTB 广告是一种实时竞价广告，就是在针对每个广告位有展示机会的时候，会实时多方竞价，价格最有优势的广告主会竞得这次展示机会，在媒体测在拿到素材的时候，需将本次成交的价格，上报给指定的监控服务器，这时就需要将实时价格按照指定的加密方案加密后，替换 GET 链接中的请求参数中的价格宏来上报。
官方给出的源代码有 Java 和 C++ 版本, 下载地址： https://code.google.com/archive/p/privatedatacommunicationprotocol/source/default/source
本文主要通过 golang 来实现的 google 的价格加密方案。
Source Code package main /* golang 实现 google 的rtb 价格加密方案 https://developers.google.com/authorized-buyers/rtb/response-guide/decrypt-price#encryption-scheme */ import ( &amp;#34;crypto/hmac&amp;#34; &amp;#34;crypto/md5&amp;#34; &amp;#34;crypto/sha1&amp;#34; &amp;#34;encoding/base64&amp;#34; &amp;#34;encoding/binary&amp;#34; &amp;#34;encoding/hex&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;hash&amp;#34; &amp;#34;math&amp;#34; &amp;#34;strings&amp;#34; ) const ( PayloadSize = 8 InitVectorSize = 16 SignatureSize = 4 EKey = &amp;#34;&amp;#34; IKey = &amp;#34;&amp;#34; UTF8 = &amp;#34;utf-8&amp;#34; ) func AddBase64Padding(base64Input string) string { var b64 string b64 = base64Input if i := len(b64) % 4; i !</description></item><item><title>Golang如何确保一个类型实现了某个interface</title><link>http://www.vimiix.com/vimiix-blog/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</link><pubDate>Thu, 29 Aug 2019 16:22:48 +0000</pubDate><guid>http://www.vimiix.com/vimiix-blog/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</guid><description>在 golang 中，接口（interface）代表一种『协议』存在，它是一个声明了多个方法的集合。
接口是被隐式实现的，也就是说，我们在开发中定义一个类型（type）的时候，不需要声明这个类型实现了哪个接口。在使用的时候往往通过断言来的 ok-idom 来进行类型判断该类型是否实现了目标接口，放置调用方法失败抛出 panic：
if value, ok := AType.(BInterface) { fmt.Println(&amp;#34;ok&amp;#34;) } else { fmt.Println(&amp;#34;no&amp;#34;) } 如果断言失败，那么 ok 的值将会是 false,但是如果断言成功 ok 的值将会是 true,同时 value 将会得到所期待的正确的值。
但是，在某些情况下，我们可能希望明确地检查接口中哪些方法没有被实现。最好的方法就是借助编译器地检查功能。
假设定义了一个 Programmer 接口，一个 Human 类型：
&amp;raquo;&amp;gt; 试一下
package main type Programmer interface { Code() string } type Human struct {} func main() {} 这段代码没有做任何操作，可以正常地执行。
假设我们希望 Human 类型实现了 Programmer 接口，可以在代码中定义一个 _ （下划线表示忽略这个变量）变量来实现检测效果
package main type Programmer interface { Code() string } type Human struct {} // 利用编译器检查接口实现 var _ Programmer = (*Human)(nil) func main() {} 当再次执行这段代码地时候，就会报出如下编译错误：</description></item></channel></rss>