<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>note on Hi, I'm Vimiix</title><link>https://www.vimiix.com/tags/note/</link><description>Recent content in note on Hi, I'm Vimiix</description><generator>Hugo -- gohugo.io</generator><language>cn-zh</language><copyright>Copyright (c) 2017-2021, Vimiix Yao; All rights reserved</copyright><lastBuildDate>Tue, 21 Dec 2021 20:25:48 +0000</lastBuildDate><atom:link href="https://www.vimiix.com/tags/note/index.xml" rel="self" type="application/rss+xml"/><item><title>分布式事务笔记(XA,TCC,Saga)</title><link>https://www.vimiix.com/posts/2021-12-21-learn-distributed-transaction/</link><pubDate>Tue, 21 Dec 2021 20:25:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2021-12-21-learn-distributed-transaction/</guid><description>基础理论 CAP理论 一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。这被称为CAP理论，已经被证实。
一致性（Consistency） ：在分布式系统中所有的数据备份，在同一时刻都保持一致状态，如无法保证状态一致，直接返回错误。 可用性（Availability）：在集群中一部分节点故障，也能保证客户端访问系统并得到正确响应，允许一定时间内数据状态不一致。 分区容错性（Partition tolerance）：分布式系统在遇到任何网络分区故障时，仍然能保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生故障。 ACID特性（刚性事务，强一致性） 把多条语句作为一个整体进行操作的功能，称为数据库事务。数据库事务可以确保该事务范围内的所有操作全部成功或者全部失败。
事务具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。
原子性（Atomicity）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 事务隔离（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 BASE理论（柔性事务） BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）
基本可用（Basically Available）：是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。 软状态（Soft state）：和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 最终一致性（Eventually consistent）：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。
分布式方案 XA规范 Open Group组织定义的一套DTP（Distributed Transaction Processing）分布式事务处理模型，主要包含以下四部分：
AP（应用程序） TM（事务管理器）：中间件，负责多个事物之间的协调 RM（资源管理器）：数据库等资源 CRM（通信资源管理器）：消息中间件 XA规范包括两套函数，分别以 xa_ 和 ax_ 开头，使 TM 可以对 RM 进行的操作：
xa_open,xa_close：建立和关闭与资源管理器的连接； xa_start,xa_end：开始和结束一个本地事务； xa_prepare,xa_commit,xa_rollback：预提交、提交、回滚一个本地事务； xa_recover：回滚一个已进行预提交的事务； ax_开头的函数使资源管理器可以动态地在事务管理器中进行注册，并可以对XID(TRANSACTION IDS)进行操作； ax_reg,ax_unreg；允许一个资源管理器在一个TMS(TRANSACTION MANAGER SERVER)中动态注册或撤消注册。 基于XA规范衍生出下面的两阶段提交（2PC）、三阶段提交（3PC）。</description></item><item><title>Golang实现Windows系统用户和密码校验</title><link>https://www.vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/</link><pubDate>Mon, 22 Mar 2021 16:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/</guid><description>本质上是通过调用 windows 的一个 API —— LogonUserW ，来实现对于用户密码的校验。
仅适用于在本地校验，不支持远程连接校验
用一个示例代码来进行说明，下面是目录结构中，main.go 是程序入口文件，auth 包中，我们仅实现 windows 系统的校验代码，其他平台不属于本文介绍内容，就直接返回 nil 即可。
目录结构 . ├── auth │ ├── auth.go │ └── auth_windows.go ├── go.mod └── main.go 源代码 [src] main.go package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.com/vimiix/authDemo/auth&amp;#34; ) func main() { user := flag.String(&amp;#34;u&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;username&amp;#34;) password := flag.String(&amp;#34;p&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;password&amp;#34;) flag.Parse() if *user == &amp;#34;&amp;#34; || *password == &amp;#34;&amp;#34; { fmt.Println(&amp;#34;Both user and password should be specify&amp;#34;) fmt.</description></item><item><title>beanstalkd消息队列</title><link>https://www.vimiix.com/posts/2020-03-11-beanstalkd-note/</link><pubDate>Wed, 11 Mar 2020 16:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2020-03-11-beanstalkd-note/</guid><description>beanstalkd 是一个简单快速的分布式工作队列系统，协议基于 ASCII 编码运行在 tcp 上。其最初设计目的是通过后台异步执行耗时任务方式降低高容量 Web 应用的页面延时。而其简单、轻量、易用等特点，和对任务优先级、延时/超时重发等控制，以及众多语言版本的客户端的良好支持，使其可以很好的在各种需要队列系统的场景中应用。
Beanstalk 的应用场景主要有：
消息异步处理（消息队列的基本需求） 消息延迟处理，实现循环队列 beanstalkd 核心组件 job : 任务，队列中的基本单元 tube : 一个有名称的任务队列，用来存储统一类型的 job ,beanstalkd 通过 tube 来实现多任务队列 producer : job 生产者，通过put命令来创建一个job放到一个tube中 comsumer : job 消费者，通过 reserve、release、bury、delete命令来获取或改变 job 的状态 job 的生命周期 在整个生命周期中 job 可能有四种工作状态：READY、RESERVED、DELAYED、BURIED. 只有处于 READY 状态的 job 才能被消费。
put with delay release with delay -------------&amp;gt; [DELAYED] &amp;lt;---------. | | | (time passes) | | | put v reserve | delete --------------&amp;gt; [READY] -------&amp;gt; [RESERVED] ------&amp;gt; *poof* ^ ^ | | | \ release | | | `-------------' | | | | kick | | | | bury | [BURIED] &amp;lt;---------------' | | delete `--------&amp;gt; *poof* Producer 创建 job 的时候可以选择两种方式：put , put with delay。</description></item><item><title>Golang如何确保一个类型实现了某个interface</title><link>https://www.vimiix.com/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</link><pubDate>Thu, 29 Aug 2019 16:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2019-08-29-how-to-ensure-a-type-implements-an-interface/</guid><description>在 golang 中，接口（interface）代表一种『协议』存在，它是一个声明了多个方法的集合。
接口是被隐式实现的，也就是说，我们在开发中定义一个类型（type）的时候，不需要声明这个类型实现了哪个接口。在使用的时候往往通过断言来的 ok-idom 来进行类型判断该类型是否实现了目标接口，放置调用方法失败抛出 panic：
if value, ok := AType.(BInterface) { fmt.Println(&amp;#34;ok&amp;#34;) } else { fmt.Println(&amp;#34;no&amp;#34;) } 如果断言失败，那么 ok 的值将会是 false,但是如果断言成功 ok 的值将会是 true,同时 value 将会得到所期待的正确的值。
但是，在某些情况下，我们可能希望明确地检查接口中哪些方法没有被实现。最好的方法就是借助编译器地检查功能。
假设定义了一个 Programmer 接口，一个 Human 类型：
&amp;raquo;&amp;gt; 试一下
package main type Programmer interface { Code() string } type Human struct {} func main() {} 这段代码没有做任何操作，可以正常地执行。
假设我们希望 Human 类型实现了 Programmer 接口，可以在代码中定义一个 _ （下划线表示忽略这个变量）变量来实现检测效果
package main type Programmer interface { Code() string } type Human struct {} // 利用编译器检查接口实现 var _ Programmer = (*Human)(nil) func main() {} 当再次执行这段代码地时候，就会报出如下编译错误：</description></item><item><title>HLS视频加密</title><link>https://www.vimiix.com/posts/2019-03-28-use-hls-to-encrypt-video/</link><pubDate>Thu, 28 Mar 2019 16:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2019-03-28-use-hls-to-encrypt-video/</guid><description>&lt;blockquote>
&lt;p>最近在做视频管理后台，主要提供点播服务，涉及到需要对视频进行加密处理以防止视频被随意下载。&lt;/p>
&lt;p>调研了一番之后确定使用 HLS(HTTP Live Streaming) 基于 HTTP 的流媒体网络传输协议技术来处理视频。&lt;/p>
&lt;p>所以本文主要记录关于学习 HLS 视频加密技术的笔记&lt;/p>
&lt;/blockquote>
&lt;h3 id="为什么要加密">为什么要加密？&lt;/h3>
&lt;p>简单的说就是：增加获取被加密资源的代价。对于视频这种资源来说，绝对的加密就是不要上线给人看，但那是不可能的，因为提供的服务就是给人看视频，只要上线，别人就可以通过各种手段解密或者简单的录屏的方式来传播，所以目前俩看，不存在绝对的加密。只要让恶意的人获取源视频的代价很大，就可以阻挡绝大多数的不法分子。这样，加密的目的也就基本达到了。&lt;/p></description></item><item><title>获取存储在又拍云CDN中视频的时长</title><link>https://www.vimiix.com/posts/2019-01-30-get-video-duration-by-upyun-sdk/</link><pubDate>Wed, 30 Jan 2019 16:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2019-01-30-get-video-duration-by-upyun-sdk/</guid><description>&lt;h3 id="前置条件">前置条件&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>可用的账户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装又拍云 Python 版本的 SDK：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">pip install upyun
&lt;/code>&lt;/pre>&lt;/div>&lt;p>（官方代码开源地址：&lt;a href="https://github.com/upyun/python-sdk/">https://github.com/upyun/python-sdk/&lt;/a> )&lt;/p></description></item><item><title>pipenv错误解决:TypeError: "module" object is not callable</title><link>https://www.vimiix.com/posts/2018-10-21-solution-of-pipenv-install-error/</link><pubDate>Sun, 21 Oct 2018 11:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-10-21-solution-of-pipenv-install-error/</guid><description>&lt;h3 id="软件版本">软件版本&lt;/h3>
&lt;p>今天在折腾一台新的云主机，所以我在安装环境的时候&lt;code>pip&lt;/code>和&lt;code>pipenv&lt;/code>都选择安装了最新版本&lt;/p>
&lt;p>（&lt;em>注：正是这两个版本配合才会出现下面的报错，旧版本或以后的新版本的 Pipenv 不会出现&lt;/em>）。&lt;/p>
&lt;p>具体如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">// pipenv 的版本 2018.7.1
$ pipenv --version
pipenv, version 2018.7.1
// pip 的版本 18.1
$ pip --version
pip 18.1 from /usr/bin/python3.6/lib/python3.6/site-packages/pip &lt;span style="color:#f92672">(&lt;/span>python 3.6&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>macOXS中使用matplotlib遇到的问题及探究</title><link>https://www.vimiix.com/posts/2018-10-16-explore-the-problem-of-matplotlib-on-macosx/</link><pubDate>Tue, 16 Oct 2018 11:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-10-16-explore-the-problem-of-matplotlib-on-macosx/</guid><description>&lt;p>第一次在 mac 系统上使用&lt;strong>matplotlib&lt;/strong>库的时候，在执行的时候，往往会遇到下面这样的问题：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ImportError: Python is not installed as a framework. balabala....
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>当然这个问题很好解决，网上有一搜就会找到如下两种解决方案：&lt;/p>
&lt;h4 id="第一种方案是在系统中设置">第一种方案是在系统中设置：&lt;/h4>
&lt;ul>
&lt;li>假设你已经通过&lt;code>pip install matplotlib&lt;/code>安装了 matplotlib，那么在你的根目录中会有一个名为&lt;code>〜/ .matplotlib&lt;/code>的目录。&lt;/li>
&lt;li>在这个目录中创建一个&lt;code>matplotlibrc&lt;/code>的文件 ,在里面添加一行代码：&lt;code>backend: TkAgg&lt;/code>，保存退出即可。&lt;/li>
&lt;/ul>
&lt;p>总结为一行 shell 命令就是：&lt;code>echo &amp;quot;backend: TkAgg&amp;quot; &amp;gt;&amp;gt; ~/.matplotlib/matplotlibrc&lt;/code>&lt;/p>
&lt;p>这种方式可以设定整个系统的 matplotlib 渲染使用的引擎，但是不好的是，代码会变得不可移植，如果服务器很多，我们需要每一台机器都去设置这个参数，这时候就需要使用第二种方案。&lt;/p>
&lt;h4 id="第二种方案是在代码中设置">第二种方案是在代码中设置：&lt;/h4>
&lt;p>在引用&lt;code>matplotlib&lt;/code>库的代码之前，添加如下两行代码（确认安装 TkInter）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> matplotlib
matplotlib&lt;span style="color:#f92672">.&lt;/span>use(&lt;span style="color:#e6db74">&amp;#39;TkAgg&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样也可以临时的修改前面提到的 &lt;code>backend&lt;/code>变量。&lt;/p></description></item><item><title>[译]实践出真知</title><link>https://www.vimiix.com/posts/2018-10-10-dont-just-learn-a-new-language-framework-implement-it-as-a-running-open-source-project/</link><pubDate>Wed, 10 Oct 2018 23:22:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-10-10-dont-just-learn-a-new-language-framework-implement-it-as-a-running-open-source-project/</guid><description>Aristotle（亚里士多德），希腊著名的哲学家和科学家，曾经说过：“对于那些我们在能做到之前必须学习如何做的事情，我们需要边做边学 (For the things we have to learn before we can do them, we learn by doing them.)”。想象一下，假如你已经读过 3 本关于骑行的书了，然后有人给你一辆自行车并让你骑它，你能骑吗？很显然，答案是“不能”。这无关乎你曾经读了多少关于骑行的书或你看了多少相关视频的事情。它需要你真正骑上一辆自行车，去保持平衡，去学习脚，手和眼睛的协调配合才能掌握的一件事情。学习新技术，新语言或框架同样也是如此。
如果现在你在想：我都不会某个语言或某个框架，我要怎么去实现这个开源项目呢，那么先停止抱怨。也许你是技术或编程的新手，但你需要知道如何去学习新事物。学习新东西的最好方法就是实践。这篇文章将重点关注普适通用的方法。它会帮助你从我想要学习&amp;rsquo;X&amp;rsquo;到我有一个项目在&amp;rsquo;X&amp;rsquo;运行，所以继续往下看。如果你决定通过做一个项目来学习新东西，那就把它开源吧。Github 是托管你的开源项目的首选服务商。在其上你可以享受很多的免费服务。这篇文章的编写主要面向编程起步者，但对于经验丰富的软件工程师也同样有用。
摘要（TLDR;） 通过编写项目来学习语言/框架，然后使用免费使用服务开源出去。不要只看课程，阅读文档，然后找到解决方案就完事，实践出真知。在项目中去使用 git 并尽量 docker 化。代码需要添加正确的代码质量检查服务以找到最佳实践，将项目部署到服务器上，让其可以对外通过 URL 访问。
不要只看课程，阅读文档，找到解决方案就完事 如今，学习新知识有很多选择。视频课程仍然是最受欢迎的媒介之一。你可以在Udemy，Pluralsight甚至Youtube上学习。在你边做边学之前，观看视频只会在某种程度上有所帮助，更好的方式是阅读官方手册。例如，阅读 React JS 文档比仅通过观看 React JS 课程更好。这样你会发现创作者的思想在其中。理清创作一个 Javascript 框架/库背后的逻辑会帮助你找到最合适的解决方案。
学习使用 Git 进行协作 “没有谁是一座孤岛” ，特别是在技术方面，你通常不会单独工作，肯定是作为团队的一员。因此，即使在学习新内容时，也要尝试找可以一起合作的人。与其它流行的代码协作工具相比，Git 非常受欢迎。当有超过 1 人为项目编写代码时，它是很有用的。你应该通过实践学习 git，可以通过查看Github 教程。我强烈推荐边做边学。当你将代码推送到 Github 之后，任何人都可以为你的项目贡献力量。
实现 docker 化，克服我的机器综合症 都8102 年了，如果你想让你的应用程序更易于使用，请使用Docker。这对于增加对开源项目的贡献也有很大帮助。使用docker compose在本地运行项目就像执行 2 个命令一样。Docker 有很多优点。对于初学者来说，这是一种确保你的应用可以在其他人的机器上以相同的方式运行的方法。在你部署应用程序的服务器上也是如此。只要它在 Docker 上运行良好，你就大可以放心，它保证可以在任何环境中无问题地运行。</description></item><item><title>TLPI笔记—深入文件I/O模型</title><link>https://www.vimiix.com/posts/2018-05-18-tpli-io-extend/</link><pubDate>Fri, 18 May 2018 09:20:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-05-18-tpli-io-extend/</guid><description>&lt;h2 id="原子操作和竞争操作">原子操作和竞争操作&lt;/h2>
&lt;p>所有的系统调用都是以原子操作方式执行的。之所以这么说，是指内核保证了某系统调用中的所有步骤会作为地理操作而一次性加以执行，期间不会被其他进程或线程中断。原子性规避了&lt;strong>竞争状态（race condition）&lt;/strong>，竞争状态指：操作共享资源的两个进程（或线程）其结果取决于一个无法预期的顺序，即这些进程或线程获得 CPU 使用权的先后相对顺序。&lt;/p></description></item><item><title>TLPI笔记—通用文件I/O模型</title><link>https://www.vimiix.com/posts/2018-05-11-tpli-common-io/</link><pubDate>Fri, 11 May 2018 09:20:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-05-11-tpli-common-io/</guid><description>&lt;h2 id="文件描述符">文件描述符&lt;/h2>
&lt;p>所有执行 I/O 操作的系统调用都是以文件描述符，一个非负整数来指代打开的文件。文件描述符用以表示所有类型的已打开的文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。每个进程都各自独立维护着一张文件描述符表。&lt;/p>
&lt;h3 id="标准文件描述符">标准文件描述符&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">文件描述符&lt;/th>
&lt;th style="text-align:center">用途&lt;/th>
&lt;th style="text-align:center">POSIX 名称&lt;/th>
&lt;th style="text-align:center">stdio 流&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">标准输入&lt;/td>
&lt;td style="text-align:center">STDIN_FILENO&lt;/td>
&lt;td style="text-align:center">stdin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">标准输出&lt;/td>
&lt;td style="text-align:center">STDOUT_FILENO&lt;/td>
&lt;td style="text-align:center">stdout&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">标准错误&lt;/td>
&lt;td style="text-align:center">STDERR_FILENO&lt;/td>
&lt;td style="text-align:center">stderr&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>TPLI笔记—linux/unix标准和历史</title><link>https://www.vimiix.com/posts/2018-05-01-linux-history/</link><pubDate>Tue, 01 May 2018 19:20:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-05-01-linux-history/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近开始阅读&lt;a href="https://book.douban.com/subject/25809330/">《Linux/Unix 系统编程手册》&lt;/a> 这本书，重新系统的学习一下 linux 系统编程方面的知识。&lt;/p>
&lt;p>在阅读完第一章《历史和标准》以后，对于很多标准名词都见过，但是对于他们之间的发展历程很是模糊，通读这部分内容后豁然开朗，尤其本章最后总结部分，对于前面的概况的既简练还没有遗漏。不禁在书上用笔写下：&lt;strong>“牛 B 总结，一气呵成”&lt;/strong>。&lt;/p>
&lt;p>方便以后不去翻书回顾，特花点时间摘录至此。&lt;/p></description></item><item><title>[python]记录关于websocket的原理和使用</title><link>https://www.vimiix.com/posts/2018-04-02-python-websocket/</link><pubDate>Mon, 02 Apr 2018 19:20:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-04-02-python-websocket/</guid><description>&lt;h2 id="什么是-websocket">什么是 websocket&lt;/h2>
&lt;p>WebSocket 是一种在单个 TCP 连接上进行&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5">全双工&lt;/a>通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建&lt;strong>持久性&lt;/strong>的连接，并进行双向数据传输。&lt;/p>
&lt;p>Websocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说的。&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;blockquote>
&lt;p>HTTP 的生命周期通过 Request 来界定，也就是发送一次 Request，收到一次 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了&lt;/p>
&lt;p>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response ， 在 HTTP 中永远是这样，也就是说一个 request 只能有一个 response。而且这个 response 也是被动的，不能主动发起。&lt;/p>
&lt;p>而对于 websocket 来说，在 HTTP 的握手基础上建立起链接，服务器端可以主动的向客户端发送数据。&lt;/p>
&lt;/blockquote></description></item><item><title>[笔记]git push卡主不动问题记录：Git push hangs on POST git-receive-pack</title><link>https://www.vimiix.com/posts/2018-03-18-git-push-hangs-on-chunked/</link><pubDate>Sun, 18 Mar 2018 18:20:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-03-18-git-push-hangs-on-chunked/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>昨天完成了&lt;a href="https://github.com/pythonzhichan/django-beginners-guide/blob/master/ClassBasedViews.md">《一个完整的 Django 入门指南》 - 第 6 部分&lt;/a>的翻译工作，本地在翻译的过程中，存储了十几张原文中的 &lt;code>png&lt;/code> 格式的插图。&lt;/p>
&lt;p>在 &lt;code>git push&lt;/code> 提交 &lt;strong>github&lt;/strong> 仓库的时候，终端显示写成功 100%, 但是一直卡在了下面这里没有推送成功：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">Counting objects: 21, &lt;span style="color:#66d9ef">done&lt;/span>.
Delta compression using up to &lt;span style="color:#ae81ff">8&lt;/span> threads.
Compressing objects: 100% &lt;span style="color:#f92672">(&lt;/span>21/21&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#66d9ef">done&lt;/span>.
Writing objects: 100% &lt;span style="color:#f92672">(&lt;/span>21/21&lt;span style="color:#f92672">)&lt;/span>, 1018.52 KiB | 17.87 MiB/s, &lt;span style="color:#66d9ef">done&lt;/span>.
Total &lt;span style="color:#ae81ff">21&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 7&lt;span style="color:#f92672">)&lt;/span>, reused &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 0&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#75715e"># 卡在这里&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[区块链]区块链和通证的应用与技术路径</title><link>https://www.vimiix.com/posts/2018-01-21-blockchain-and-token/</link><pubDate>Sun, 21 Jan 2018 22:37:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2018-01-21-blockchain-and-token/</guid><description>&lt;blockquote>
&lt;p>前言：1 月 21 日参加 CSDN 举办的区块链沙龙，以下是来自 CSDN 副总裁孟岩的 Slide 笔记。表达上使用了个人的理解，如果有哪里理解错误，还请在评论中指正。&lt;/p>
&lt;/blockquote>
&lt;h2 id="产业形势和发展方向">产业形势和发展方向&lt;/h2>
&lt;h3 id="三大派别">三大派别&lt;/h3>
&lt;p>目前国内的区块链产业形势分为 &lt;code>币&lt;/code>，&lt;code>证&lt;/code>，&lt;code>链&lt;/code>三个派别，这三个群体需要分开来评判看待。&lt;/p>
&lt;p>最为我们大众所熟知的一些企业，或者说是一些数字货币，大都属于&lt;code>币&lt;/code>圈公司。这一类公司可以用六个字总结：“只造势，不做事”。各种铺天盖地的宣传，为的是制造其发行的数字货币的影响力，而并没有实际的实体价值依托。&lt;/p>
&lt;p>因为我们大家日常接触或听到的大部分都是币圈的公司信息，所以常常会有人说：“区块链这个技术没有实际的落地应用，只是个噱头”。其实不然，国外其实有很多的公司在做着基于区块链技术的应用，只是因为这一类的公司不会去发行数字货币，也不发通证（通证的概念后面会提到），只是在借助区块链技术在做着一些实际的应用产品，所以往往不被人所了解。这一类的公司就属于&lt;code>链圈&lt;/code>公司范畴。链圈的公司会有很多基于区块链技术的落地应用，但是因为每个产品都是独立的，影响力是很有限的，所以无法对全球产生&lt;code>革命&lt;/code>性的改变。&lt;/p>
&lt;p>还有第三个派别就是&amp;mdash;“通证派”。首先理解一下通证的定义，通证，英文的名字是&lt;code>Token&lt;/code>，还有的人译作“代币”，但是这个真不是一个很雅的翻译，我更倾向于称之为“通证”。通证的核心是&lt;code>通&lt;/code>，流通，通证是一种价值转移的载体形式。&lt;/p>
&lt;p>通证有广义的通证和狭义的通证之分，狭义的通证包含但不限于：身份证，房产证，信用卡，用户积分，通行证，门票，购物卡，发票，股票，债券等等&amp;hellip;广义的通证是在狭义的通证基础上多一个&lt;code>数字加密货币&lt;/code>。&lt;/p></description></item></channel></rss>