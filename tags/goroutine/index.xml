<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>goroutine on Hi, I'm Vimiix</title><link>http://vimiix.com/vimiix-blog/tags/goroutine/</link><description>Recent content in goroutine on Hi, I'm Vimiix</description><generator>Hugo -- gohugo.io</generator><language>cn-zh</language><copyright>Copyright (c) 2017-2021, Vimiix Yao; All rights reserved</copyright><lastBuildDate>Wed, 07 Apr 2021 18:15:48 +0000</lastBuildDate><atom:link href="http://vimiix.com/vimiix-blog/tags/goroutine/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang的并行模式实践</title><link>http://vimiix.com/vimiix-blog/posts/2021-04-07-concurrency-in-go/</link><pubDate>Wed, 07 Apr 2021 18:15:48 +0000</pubDate><guid>http://vimiix.com/vimiix-blog/posts/2021-04-07-concurrency-in-go/</guid><description>Goroutine C#、Lua、Python 的用户可能会发现 Go 的 goroutine 和协程之间有很多相似之处，没错，从命名上也可以看出二者具有相似性。
但二者之间也有些区别：
goroutine 隐含了并行的特性，一切交给 go 的 runtime 来实现调度，而协程需要应用自己来编写并行代码 goroutine 通过信道（Channel）进行通信；协程通过 yield 和 next操作进行通信 一般来说，goroutine 比协程更强大。而且，我们可以很容易地将协程的逻辑移植到 goroutine 来获得更好的并行效果。
Generators 在 python 中，要实现一个生成器，需要通过 yield 生成数据，通过 next 获取数据：
def integers(): i = 1 while True: yield i i+=1 integerGenerator = integers() next(integerGenerator) # 1 next(integerGenerator) # 2 next(integerGenerator) # 3 同样的，生成器也可以在 Go 中实现，只是使用了 channel 来代替 yield:
func integers () chan int { yield := make (chan int); count := 0; go func () { for { yield &amp;lt;- count; count++; } } (); return yield } next := integers(); func generateInteger () int { return &amp;lt;-next } generateInteger() // 0 generateInteger() // 1 generateInteger() // 2 Iterators go 的 channel 在语法层面就是天然的迭代器。</description></item></channel></rss>