<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>goroutine on Hi, I'm Vimiix</title><link>https://www.vimiix.com/tags/goroutine/</link><description>Recent content in goroutine on Hi, I'm Vimiix</description><generator>Hugo -- gohugo.io</generator><language>cn-zh</language><copyright>Copyright (c) 2017-2024, Vimiix Yao; All rights reserved</copyright><lastBuildDate>Wed, 07 Apr 2021 18:15:48 +0000</lastBuildDate><atom:link href="https://www.vimiix.com/tags/goroutine/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang的并行模式实践</title><link>https://www.vimiix.com/posts/2021-04-07-concurrency-in-go/</link><pubDate>Wed, 07 Apr 2021 18:15:48 +0000</pubDate><guid>https://www.vimiix.com/posts/2021-04-07-concurrency-in-go/</guid><description>&lt;h2 id="goroutine">Goroutine&lt;/h2>
&lt;p>C#、Lua、Python 的用户可能会发现 Go 的 goroutine 和协程之间有很多相似之处，没错，从命名上也可以看出二者具有相似性。&lt;/p>
&lt;p>但二者之间也有些区别：&lt;/p>
&lt;ul>
&lt;li>goroutine 隐含了并行的特性，一切交给 go 的 runtime 来实现调度，而协程需要应用自己来编写并行代码&lt;/li>
&lt;li>goroutine 通过信道（&lt;code>Channel&lt;/code>）进行通信；协程通过 &lt;code>yield&lt;/code> 和 &lt;code>next&lt;/code>操作进行通信&lt;/li>
&lt;/ul>
&lt;p>一般来说，goroutine 比协程更强大。而且，我们可以很容易地将协程的逻辑移植到 goroutine 来获得更好的并行效果。&lt;/p></description></item></channel></rss>