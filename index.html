<!doctype html><html lang=cn-zh><head><meta name=generator content="Hugo 0.120.4"><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Hi, I'm Vimiix</title>
<meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title="Hi, I'm Vimiix"></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1><a href=https://www.vimiix.com/posts/2024-02-20-be-a-better-developer-with-these-git-good-practices/>[译]做一个拥有 Git 好习惯的开发者</a></h1><b><time>2024.02.20 00:50</time></b>
<a href=/tags/translation>translation</a>
<a href=/tags/git>git</a>
<a href=/tags/best-practices>best-practices</a><div>如果你是一名开发人员，你可能每天都会使用 git 作为版本控制系统。这个工具的使用对于应用程序的开发过程是至关重要的，无论是在团队协作还是单独工作。但是，常常会遇到混乱的项目库，提交的 commit 信息不明确，不能传达有用的内容，以及滥用分支等问题。了解如何正确使用 git 并遵循良好的实践对于那些想要在就业市场中脱颖而出的人来说是必不可少的。
Git 分支的命名约定 当我们在处理代码版本控制时，我们应该遵循的一个好的习惯，就是为分支、提交、拉取请求等使用清晰和描述性的名称。确保所有团队成员都有一个简洁的工作流程是至关重要的。除了提高工作效率之外，记录项目的开发过程也简化了团队合作。通过遵循这些实践，你很快就会获益其中。
基于此，开发者社区创建了一些分支命名的约定，你可以在项目中遵循这些约定。虽然遵循下列规则不是硬性的要求，但它们可以帮助你提高开发技能。
使用小写字母：分支名称不要用大写字母，强制小写; 连字符分隔：如果分支名称包含多个单词，请使用连字符将它们分开，遵循短横线命名法。避免使用帕斯卡命名法、驼峰命名法或蛇形命名法; (a-z, 0-9)：分支名称中只使用字母数字字符和连字符，避免使用其他字符; 不要使用连续的连字符(&ndash;)：这种做法可能令人困惑。例如，如果你有分支类型(如feature, bugfix, hotfix等)，使用斜杠(/)代替; 避免在分支名称的末尾使用连字符：这是没有意义的，因为连字符分隔单词，最后没有单词要分隔; 最重要的：使用描述性的、简洁的、清晰的名称来定义分支上做了什么; 不好的分支命名：
fixSidebar feature-new-sidebar- FeatureNewSidebar feat_add_sidebar 好的分支名：
feature/new-sidebar add-new-sidebar hotfix/interval-query-param-on-get-historical-data 分支名称约定前缀 有时分支的目的并不明确。它可以是一个新特性、错误修复、文档更新或其他任何东西。为了解决这个问题，通常的做法是在分支名称上使用前缀来快速解释分支的目的。
feature：它表达了一个将被开发的新功能。例如：feature/add-filters; release：用于准备新版本的发布。release/ 前缀通常用于在合并分支主版本的新更新以创建版本之前执行诸如最后修改和修订之类的任务。例如，release/v3.3.1-beta; bugfix：它表达的信息是，你正在解决代码中的一个bug，而且它通常与一个问题有关。例如，bugfix/sign-in-flow; hotfix：类似于 bugfix，但它与修复生产环境中存在的关键错误有关。例如，hotfix/cors-error; docs：写一些文档。例如，docs/quick-start; 如果你在工作中使用任务管理相关的工具，如Jira, Trello, ClickUp，或任何类似的工具，可以考虑先创建用户故事卡，每张卡有一个数字相关联。所以，通常可以把这些卡的编号用在分支名称的前缀中。例如：
feature/T-531-add-sidebar docs/T-789-update-readme hotfix/T-142-security-path 提交信息 Commit message 接下来，我们来讨论一下提交消息。不幸的是，我们经常会看到这样的提交信息，如：“added a lot of things”或“Pikachu, I choose you”等（是的，我曾经发现一个项目的提交信息与poksammon战斗有关）。
提交信息在开发过程中非常重要，创造一段美好的历史会在你的人生旅途中给你带来很多帮助。和分支一样，社区也有对于提交信息的规范约定，你可以在下面了解到:
提交消息有三个重要部分:主题 Subject、描述 Description和页脚 Footer。提交的主题是必需的，并且定义了提交的目的。描述(主体)用于为提交的目的提供额外的上下文和解释。最后是页脚，通常用于元数据，如分配提交。虽然同时使用描述和页脚被认为是一种很好的做法，但这不是必需的。 在主题行中使用祈使句。 例如： Add README.md ✅; Added README.md ❌; Adding README.md ❌;
<a href=https://www.vimiix.com/posts/2024-02-20-be-a-better-developer-with-these-git-good-practices/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2023-12-15-ssx/>SSX，一个有记忆的 ssh 客户端</a></h1><b><time>2023.12.15 00:50</time></b>
<a href=/tags/golang>golang</a>
<a href=/tags/ssx>ssx</a>
<a href=/tags/ssh>ssh</a>
<a href=/tags/tools>tools</a><div><h2 id=需求来源>需求来源</h2><p>对于一个后端程序员来说，在工作中免不了要和繁杂的服务器打交道，ssh 是不可或缺的开发工具。但每次登录都需要输入密码的行为，对于认为一切皆可自动化的程序员来说，肯定是有点繁琐的（如果您是使用图形化界面的用户可忽略）。</p><p>所以我在前段时间考虑，我应该自己实现一个 ssh 客户端，它不需要拥有许多复杂的功能，只需要满足我以下这几个需求即可满足日常使用：</p><ul><li>和 ssh 保持差不多的使用习惯</li><li>仅在第一次登录时询问我密码，后续使用无需再提供密码</li><li>可以给服务器它任意的标签，这样我就可以自由地通过IP 或者标签来登录</li></ul><p>于是乎，近期我在业余时间就设计并编写了 <a href=https://github.com/vimiix/ssx>ssx</a> 这个轻量级的具有记忆的 ssh 客户端。它完美的实现了上面我所需要的功能，也已经被我愉快的应用到了日常的开发中。</p><a href=https://www.vimiix.com/posts/2023-12-15-ssx/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2023-06-21-manage-go-multiple-versions/>Shell 函数实现Go语言多版本管理轻量级方案</a></h1><b><time>2023.06.21 14:50</time></b>
<a href=/tags/golang>golang</a>
<a href=/tags/solution>solution</a>
<a href=/tags/multi-version>multi-version</a><div><h2 id=现有的工具方案>现有的工具方案</h2><ul><li>gvm: <a href=https://github.com/moovweb/gvm>https://github.com/moovweb/gvm</a></li><li>g: <a href=https://github.com/voidint/g>https://github.com/voidint/g</a></li></ul><h2 id=我的方案>我的方案</h2><p>优点：</p><ul><li>原生：基于 go 语言本身支持多版本的能力实现，可以下载任何官方发布的版本</li><li>简单：shell 函数实现，直接集成到 bashrc 或 zshrc 中即可使用，无需额外配置</li><li>可定制化：代码简单可根据自身需求定制</li></ul><a href=https://www.vimiix.com/posts/2023-06-21-manage-go-multiple-versions/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-12-21-learn-distributed-transaction/>分布式事务笔记(XA,TCC,Saga)</a></h1><b><time>2021.12.21 20:25</time></b>
<a href=/tags/distributed>distributed</a>
<a href=/tags/note>note</a><div><h2 id=基础理论>基础理论</h2><h3 id=cap理论>CAP理论</h3><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。这被称为CAP理论，已经被证实。</p><ul><li>一致性（Consistency） ：在分布式系统中所有的数据备份，在同一时刻都保持一致状态，如无法保证状态一致，直接返回错误。</li><li>可用性（Availability）：在集群中一部分节点故障，也能保证客户端访问系统并得到正确响应，允许一定时间内数据状态不一致。</li><li>分区容错性（Partition tolerance）：分布式系统在遇到任何网络分区故障时，仍然能保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生故障。</li></ul><a href=https://www.vimiix.com/posts/2021-12-21-learn-distributed-transaction/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-09-01-simulate-disk-readonly-scenario/>磁盘只读（readonly）故障场景模拟</a></h1><b><time>2021.09.01 16:15</time></b>
<a href=/tags/disk>disk</a>
<a href=/tags/simulate>simulate</a>
<a href=/tags/test>test</a><div><p>假设服务器目前有多个盘，<code>vdb1</code>这块分区盘专门用于数据库程序的数据目录，我们就用 <code>vdb1</code> 这个盘来模拟只读故障场景。</p><p><figure><img src=https://static.vimiix.com/upic/2021-09-01/image-20210901154323971.png alt=image-20210901154323971></figure></p><h3 id=1-卸载指定盘>1. 卸载指定盘</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>umount /dev/vdb1
</span></span></code></pre></div><p>想要如期卸载掉，需要确保该盘上没有被正在运行进程依赖，如果有运行中的进程依赖这个盘，会报如下报 <code>target is busy</code> 的错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>umount: /opt: target is busy.
</span></span></code></pre></div><p>遇到该错误时，可以通过<code>lsof [mountpoint]</code> 命令来查看有哪些进程依赖这块盘，kill 掉相应的进程后重新卸载。</p><a href=https://www.vimiix.com/posts/2021-09-01-simulate-disk-readonly-scenario/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-07-08-opengauss-driver-and-orm/>使用SQLAlchemy以多IP方式连接openGauss数据库</a></h1><b><time>2021.07.08 23:38</time></b>
<a href=/tags/sqlalchemy>SQLAlchemy</a>
<a href=/tags/python>Python</a>
<a href=/tags/opengauss>openGauss</a><div><h3 id=前置声明>前置声明</h3><blockquote><p>由于 <a href=https://opengauss.org/zh/>openGauss</a> 数据库本身也开源不久，所以周边基础设施也正处于遍地开花的阶段，所以本文不保证长期的时效性，仅针对现阶段的问题，提出一种解决方案。</p></blockquote><h2 id=opengauss-介绍>openGauss 介绍</h2><p>按照官网的介绍，openGauss 是一款高性能，高安全，高可靠的开源关系型数据库管理系统，采用木兰宽松许可证v2发行。openGauss内核早期源自开源数据库PostgreSQL，融合了华为在数据库领域多年的内核经验，在架构、事务、存储引擎、优化器及ARM架构上进行了适配与优化。</p><p>openGauss 在2020年6月30日开放源代码，代码托管在 gitee 上。</p><p>目前我所在公司也主要是做数据库方面的事情，且也基于 openGauss 内核研发了一款商业版的数据库 <a href=https://enmotech.com/products/MogDB>MogDB</a>，感兴趣的也可以去了解一下。</p><a href=https://www.vimiix.com/posts/2021-07-08-opengauss-driver-and-orm/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-04-07-concurrency-in-go/>Golang的并行模式实践</a></h1><b><time>2021.04.07 18:15</time></b>
<a href=/tags/concurrency>concurrency</a>
<a href=/tags/golang>golang</a>
<a href=/tags/goroutine>goroutine</a><div><h2 id=goroutine>Goroutine</h2><p>C#、Lua、Python 的用户可能会发现 Go 的 goroutine 和协程之间有很多相似之处，没错，从命名上也可以看出二者具有相似性。</p><p>但二者之间也有些区别：</p><ul><li>goroutine 隐含了并行的特性，一切交给 go 的 runtime 来实现调度，而协程需要应用自己来编写并行代码</li><li>goroutine 通过信道（<code>Channel</code>）进行通信；协程通过 <code>yield</code> 和 <code>next</code>操作进行通信</li></ul><p>一般来说，goroutine 比协程更强大。而且，我们可以很容易地将协程的逻辑移植到 goroutine 来获得更好的并行效果。</p><a href=https://www.vimiix.com/posts/2021-04-07-concurrency-in-go/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/>Golang实现Windows系统用户和密码校验</a></h1><b><time>2021.03.22 16:22</time></b>
<a href=/tags/note>note</a>
<a href=/tags/windows>windows</a>
<a href=/tags/golang>golang</a><div><p>本质上是通过调用 windows 的一个 API —— <a href=https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonuserw><code>LogonUserW</code></a> ，来实现对于用户密码的校验。</p><blockquote><p>仅适用于在本地校验，不支持远程连接校验</p></blockquote><p>用一个示例代码来进行说明，下面是目录结构中，<code>main.go</code> 是程序入口文件，auth 包中，我们仅实现 windows 系统的校验代码，其他平台不属于本文介绍内容，就直接返回 nil 即可。</p><a href=https://www.vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2020-03-11-beanstalkd-note/>beanstalkd消息队列</a></h1><b><time>2020.03.11 16:22</time></b>
<a href=/tags/beanstalkd>beanstalkd</a>
<a href=/tags/note>note</a>
<a href=/tags/python>Python</a>
<a href=/tags/mq>MQ</a><div><p>beanstalkd 是一个简单快速的分布式工作队列系统，协议基于 ASCII 编码运行在 tcp 上。其最初设计目的是通过后台异步执行耗时任务方式降低高容量 Web 应用的页面延时。而其简单、轻量、易用等特点，和对任务优先级、延时/超时重发等控制，以及<a href=https://github.com/beanstalkd/beanstalkd/wiki/Client-Libraries>众多语言版本的客户端</a>的良好支持，使其可以很好的在各种需要队列系统的场景中应用。</p><p>Beanstalk 的应用场景主要有：</p><ul><li>消息异步处理（消息队列的基本需求）</li><li>消息延迟处理，实现循环队列</li></ul><a href=https://www.vimiix.com/posts/2020-03-11-beanstalkd-note/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2020-02-21-richardson-model/>[译]Richardson成熟度模型</a></h1><b><time>2020.02.21 16:22</time></b>
<a href=/tags/translation>translation</a>
<a href=/tags/richardson>Richardson</a><div><blockquote><p>原文链接：<a href=https://martinfowler.com/articles/richardsonMaturityModel.html>https://martinfowler.com/articles/richardsonMaturityModel.html</a></p></blockquote><h3 id=迈向-rest-的荣耀之巅>迈向 REST 的荣耀之巅</h3><p>Leonard Richardson 提出的一个模型，将实现 REST 方法的主要元素分解为三个步骤，分别包括：资源（Resources）、HTTP 动词(HTTP Verbs，如<code>GET</code>、<code>POST</code>等)和超媒体控制（Hypermedia Controls）。</p><p>在<a href="https://www.amazon.cn/dp/0596805829/ref=sr_1_1?ie=UTF8&amp;qid=1551228104&amp;sr=8-1&amp;keywords=REST+in+Practice">Rest In Practice</a>一书中，解释了如何使用 Restful Web Service 来处理企业面临的许多集成问题。本书的核心观点是，Web 就是一个大规模可扩展的分布式系统存在、并可以很好的工作的证明，而我们可以根据这一观点更容易地构建集成系统。</p><p><figure><img src=https://static.vimiix.com/uPic/2021-04-06/5hdvom.png alt></figure></p><a href=https://www.vimiix.com/posts/2020-02-21-richardson-model/>Read more...</a></div></article><div>1 of 9
<a href=/page/2/>下一页</a></div></main><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2024
Copyright (c) 2017-2021, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>