<!doctype html><html lang=cn-zh><head><meta name=generator content="Hugo 0.120.4"><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Hi, I'm Vimiix</title>
<meta name=description content="A blog maintained by Vimiix."><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title="Hi, I'm Vimiix"></head><body><header>====================<br>== Hi, I'm Vimiix ==<br>====================<div style=float:right>Practice makes perfect (ง •̀_•́)ง</div><br><p><nav><a href=https://www.vimiix.com/><b>首页</b></a>.
<a href=/posts/><b>文章列表</b></a>.
<a href=/categories/><b>分类</b></a>.
<a href=/tags/><b>标签</b></a>.
<a href=/friends/><b>友链</b></a>.
<a href=/about/><b>关于</b></a>.
<a href=/index.xml><b>RSS</b></a>.</nav></p></header><main><article><h1><a href=https://www.vimiix.com/posts/2024-02-20-be-a-better-developer-with-these-git-good-practices/>[译]做一个拥有 Git 好习惯的开发者</a></h1><b><time>2024.02.20 00:50</time></b>
<a href=/tags/translation>translation</a>
<a href=/tags/git>git</a>
<a href=/tags/best-practices>best-practices</a><div><p>如果你是一名开发人员，你可能每天都会使用 git 作为版本控制系统。这个工具的使用对于应用程序的开发过程是至关重要的，无论是在团队协作还是单独工作。但是，常常会遇到混乱的项目库，提交的 commit 信息不明确，不能传达有用的内容，以及滥用分支等问题。了解如何正确使用 git 并遵循良好的实践对于那些想要在就业市场中脱颖而出的人来说是必不可少的。</p><a href=https://www.vimiix.com/posts/2024-02-20-be-a-better-developer-with-these-git-good-practices/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2023-12-15-ssx/>SSX，一个有记忆的 ssh 客户端</a></h1><b><time>2023.12.15 00:50</time></b>
<a href=/tags/golang>golang</a>
<a href=/tags/ssx>ssx</a>
<a href=/tags/ssh>ssh</a>
<a href=/tags/tools>tools</a><div><h2 id=需求来源>需求来源</h2><p>对于一个后端程序员来说，在工作中免不了要和繁杂的服务器打交道，ssh 是不可或缺的开发工具。但每次登录都需要输入密码的行为，对于认为一切皆可自动化的程序员来说，肯定是有点繁琐的（如果您是使用图形化界面的用户可忽略）。</p><p>所以我在前段时间考虑，我应该自己实现一个 ssh 客户端，它不需要拥有许多复杂的功能，只需要满足我以下这几个需求即可满足日常使用：</p><ul><li>和 ssh 保持差不多的使用习惯</li><li>仅在第一次登录时询问我密码，后续使用无需再提供密码</li><li>可以给服务器它任意的标签，这样我就可以自由地通过IP 或者标签来登录</li></ul><p>于是乎，近期我在业余时间就设计并编写了 <a href=https://github.com/vimiix/ssx>ssx</a> 这个轻量级的具有记忆的 ssh 客户端。它完美的实现了上面我所需要的功能，也已经被我愉快的应用到了日常的开发中。</p><a href=https://www.vimiix.com/posts/2023-12-15-ssx/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2023-06-21-manage-go-multiple-versions/>Shell 函数实现Go语言多版本管理轻量级方案</a></h1><b><time>2023.06.21 14:50</time></b>
<a href=/tags/golang>golang</a>
<a href=/tags/solution>solution</a>
<a href=/tags/multi-version>multi-version</a><div><h2 id=现有的工具方案>现有的工具方案</h2><ul><li>gvm: <a href=https://github.com/moovweb/gvm>https://github.com/moovweb/gvm</a></li><li>g: <a href=https://github.com/voidint/g>https://github.com/voidint/g</a></li></ul><h2 id=我的方案>我的方案</h2><p>优点：</p><ul><li>原生：基于 go 语言本身支持多版本的能力实现，可以下载任何官方发布的版本</li><li>简单：shell 函数实现，直接集成到 bashrc 或 zshrc 中即可使用，无需额外配置</li><li>可定制化：代码简单可根据自身需求定制</li></ul><a href=https://www.vimiix.com/posts/2023-06-21-manage-go-multiple-versions/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-12-21-learn-distributed-transaction/>分布式事务笔记(XA,TCC,Saga)</a></h1><b><time>2021.12.21 20:25</time></b>
<a href=/tags/distributed>distributed</a>
<a href=/tags/note>note</a><div><h2 id=基础理论>基础理论</h2><h3 id=cap理论>CAP理论</h3><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。这被称为CAP理论，已经被证实。</p><ul><li>一致性（Consistency） ：在分布式系统中所有的数据备份，在同一时刻都保持一致状态，如无法保证状态一致，直接返回错误。</li><li>可用性（Availability）：在集群中一部分节点故障，也能保证客户端访问系统并得到正确响应，允许一定时间内数据状态不一致。</li><li>分区容错性（Partition tolerance）：分布式系统在遇到任何网络分区故障时，仍然能保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生故障。</li></ul><a href=https://www.vimiix.com/posts/2021-12-21-learn-distributed-transaction/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-09-01-simulate-disk-readonly-scenario/>磁盘只读（readonly）故障场景模拟</a></h1><b><time>2021.09.01 16:15</time></b>
<a href=/tags/disk>disk</a>
<a href=/tags/simulate>simulate</a>
<a href=/tags/test>test</a><div><p>假设服务器目前有多个盘，<code>vdb1</code>这块分区盘专门用于数据库程序的数据目录，我们就用 <code>vdb1</code> 这个盘来模拟只读故障场景。</p><p><figure><img src=https://static.vimiix.com/upic/2021-09-01/image-20210901154323971.png alt=image-20210901154323971></figure></p><h3 id=1-卸载指定盘>1. 卸载指定盘</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>umount /dev/vdb1
</span></span></code></pre></div><p>想要如期卸载掉，需要确保该盘上没有被正在运行进程依赖，如果有运行中的进程依赖这个盘，会报如下报 <code>target is busy</code> 的错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>umount: /opt: target is busy.
</span></span></code></pre></div><p>遇到该错误时，可以通过<code>lsof [mountpoint]</code> 命令来查看有哪些进程依赖这块盘，kill 掉相应的进程后重新卸载。</p><a href=https://www.vimiix.com/posts/2021-09-01-simulate-disk-readonly-scenario/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-07-08-opengauss-driver-and-orm/>使用SQLAlchemy以多IP方式连接openGauss数据库</a></h1><b><time>2021.07.08 23:38</time></b>
<a href=/tags/sqlalchemy>SQLAlchemy</a>
<a href=/tags/python>Python</a>
<a href=/tags/opengauss>openGauss</a><div><h3 id=前置声明>前置声明</h3><blockquote><p>由于 <a href=https://opengauss.org/zh/>openGauss</a> 数据库本身也开源不久，所以周边基础设施也正处于遍地开花的阶段，所以本文不保证长期的时效性，仅针对现阶段的问题，提出一种解决方案。</p></blockquote><h2 id=opengauss-介绍>openGauss 介绍</h2><p>按照官网的介绍，openGauss 是一款高性能，高安全，高可靠的开源关系型数据库管理系统，采用木兰宽松许可证v2发行。openGauss内核早期源自开源数据库PostgreSQL，融合了华为在数据库领域多年的内核经验，在架构、事务、存储引擎、优化器及ARM架构上进行了适配与优化。</p><p>openGauss 在2020年6月30日开放源代码，代码托管在 gitee 上。</p><p>目前我所在公司也主要是做数据库方面的事情，且也基于 openGauss 内核研发了一款商业版的数据库 <a href=https://enmotech.com/products/MogDB>MogDB</a>，感兴趣的也可以去了解一下。</p><a href=https://www.vimiix.com/posts/2021-07-08-opengauss-driver-and-orm/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-04-07-concurrency-in-go/>Golang的并行模式实践</a></h1><b><time>2021.04.07 18:15</time></b>
<a href=/tags/concurrency>concurrency</a>
<a href=/tags/golang>golang</a>
<a href=/tags/goroutine>goroutine</a><div><h2 id=goroutine>Goroutine</h2><p>C#、Lua、Python 的用户可能会发现 Go 的 goroutine 和协程之间有很多相似之处，没错，从命名上也可以看出二者具有相似性。</p><p>但二者之间也有些区别：</p><ul><li>goroutine 隐含了并行的特性，一切交给 go 的 runtime 来实现调度，而协程需要应用自己来编写并行代码</li><li>goroutine 通过信道（<code>Channel</code>）进行通信；协程通过 <code>yield</code> 和 <code>next</code>操作进行通信</li></ul><p>一般来说，goroutine 比协程更强大。而且，我们可以很容易地将协程的逻辑移植到 goroutine 来获得更好的并行效果。</p><a href=https://www.vimiix.com/posts/2021-04-07-concurrency-in-go/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/>Golang实现Windows系统用户和密码校验</a></h1><b><time>2021.03.22 16:22</time></b>
<a href=/tags/note>note</a>
<a href=/tags/windows>windows</a>
<a href=/tags/golang>golang</a><div><p>本质上是通过调用 windows 的一个 API —— <a href=https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonuserw><code>LogonUserW</code></a> ，来实现对于用户密码的校验。</p><blockquote><p>仅适用于在本地校验，不支持远程连接校验</p></blockquote><p>用一个示例代码来进行说明，下面是目录结构中，<code>main.go</code> 是程序入口文件，auth 包中，我们仅实现 windows 系统的校验代码，其他平台不属于本文介绍内容，就直接返回 nil 即可。</p><a href=https://www.vimiix.com/posts/2021-03-22-auth-windows-user-in-golang/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2020-03-11-beanstalkd-note/>beanstalkd消息队列</a></h1><b><time>2020.03.11 16:22</time></b>
<a href=/tags/beanstalkd>beanstalkd</a>
<a href=/tags/note>note</a>
<a href=/tags/python>Python</a>
<a href=/tags/mq>MQ</a><div><p>beanstalkd 是一个简单快速的分布式工作队列系统，协议基于 ASCII 编码运行在 tcp 上。其最初设计目的是通过后台异步执行耗时任务方式降低高容量 Web 应用的页面延时。而其简单、轻量、易用等特点，和对任务优先级、延时/超时重发等控制，以及<a href=https://github.com/beanstalkd/beanstalkd/wiki/Client-Libraries>众多语言版本的客户端</a>的良好支持，使其可以很好的在各种需要队列系统的场景中应用。</p><p>Beanstalk 的应用场景主要有：</p><ul><li>消息异步处理（消息队列的基本需求）</li><li>消息延迟处理，实现循环队列</li></ul><a href=https://www.vimiix.com/posts/2020-03-11-beanstalkd-note/>Read more...</a></div></article><article><h1><a href=https://www.vimiix.com/posts/2020-02-21-richardson-model/>[译]Richardson成熟度模型</a></h1><b><time>2020.02.21 16:22</time></b>
<a href=/tags/translation>translation</a>
<a href=/tags/richardson>Richardson</a><div><blockquote><p>原文链接：<a href=https://martinfowler.com/articles/richardsonMaturityModel.html>https://martinfowler.com/articles/richardsonMaturityModel.html</a></p></blockquote><h3 id=迈向-rest-的荣耀之巅>迈向 REST 的荣耀之巅</h3><p>Leonard Richardson 提出的一个模型，将实现 REST 方法的主要元素分解为三个步骤，分别包括：资源（Resources）、HTTP 动词(HTTP Verbs，如<code>GET</code>、<code>POST</code>等)和超媒体控制（Hypermedia Controls）。</p><p>在<a href="https://www.amazon.cn/dp/0596805829/ref=sr_1_1?ie=UTF8&amp;qid=1551228104&amp;sr=8-1&amp;keywords=REST+in+Practice">Rest In Practice</a>一书中，解释了如何使用 Restful Web Service 来处理企业面临的许多集成问题。本书的核心观点是，Web 就是一个大规模可扩展的分布式系统存在、并可以很好的工作的证明，而我们可以根据这一观点更容易地构建集成系统。</p><p><figure><img src=https://static.vimiix.com/uPic/2021-04-06/5hdvom.png alt></figure></p><a href=https://www.vimiix.com/posts/2020-02-21-richardson-model/>Read more...</a></div></article><div>1 of 9
<a href=/page/2/>下一页</a></div></main><footer><p><a href=https://github.com/vimiix><b>Github</b></a>.
<a href=https://www.douban.com/people/vimiix/><b>Douban</b></a>.
<a href=mailto:i@vimiix.com><b>Email</b></a>.<br>&copy; 2024
Copyright (c) 2017-2024, Vimiix Yao; All rights reserved.
<a href=https://beian.miit.gov.cn/>京ICP备19015214号-1</a></p></footer></body></html>